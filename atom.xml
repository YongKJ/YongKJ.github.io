<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YongKJ</title>
  
  <subtitle>勇往直前，永不言弃</subtitle>
  <link href="https://blog.yongkj.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.yongkj.cn/"/>
  <updated>2021-02-10T07:59:14.000Z</updated>
  <id>https://blog.yongkj.cn/</id>
  
  <author>
    <name>yongkj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>输入输出流</title>
    <link href="https://blog.yongkj.cn/2021/02/09/java-io-stream/"/>
    <id>https://blog.yongkj.cn/2021/02/09/java-io-stream/</id>
    <published>2021-02-09T13:07:52.000Z</published>
    <updated>2021-02-10T07:59:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>Java对数据的操作是通过流的方式，IO流用来处理设备之间的数据传输，上传文件和下载文件，Java用于操作流的对象都在IO包中。</li></ol><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><p><img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/20160522165107051.jpg" alt="20160522165107051.jpg"></p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ol><li>字节流基类</li></ol><p>​      1）InputStream</p><blockquote><p>InputStream：字节输入流基类，抽象类是表示字节输入流的所有类的超类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从输入流中读取数据的下一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将输入流中最多 len 个数据字节读入 byte 数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跳过和丢弃此输入流中数据的 n个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭此输入流并释放与该流关联的所有系统资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>​      2）OutputStream</p><blockquote><p>OutputStream：字节输出流基类，抽象类是表示输出字节流的所有类的超类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 b.length 个字节从指定的 byte 数组写入此输出流</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的字节写入此输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭此输出流并释放与此流有关的所有系统资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 刷新此输出流并强制写出所有缓冲的输出字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>字节文件操作流</li></ol><p>​      1）FileInputStream</p><blockquote><p>FileInputStream：字节文件输入流，从文件系统中的某个文件中获得输入字节，用于读取诸如图像数据之类的原始字节流。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">    <span class="comment">// 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的File对象file指定</span></span><br><span class="line">    FileInputStream(File file)</span><br><span class="line">    <span class="comment">// 通过打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的路径name指定</span></span><br><span class="line">    FileInputStream(String name)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取f盘下该文件f://hell/test.txt</span></span><br><span class="line">        <span class="comment">//构造方法1</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;f://hello//test.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一次读取一个字节</span></span><br><span class="line">        <span class="keyword">while</span> ((i = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.print(i + &quot; &quot;);// 65 66 67 68</span></span><br><span class="line">            <span class="comment">//为什么会输出65 66 67 68？因为字符在底层存储的时候就是存储的数值。即字符对应的ASCII码。</span></span><br><span class="line">            System.out.print((<span class="keyword">char</span>) i + <span class="string">&quot; &quot;</span>);<span class="comment">// A B C D</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭IO流</span></span><br><span class="line">        inputStream.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取f盘下该文件f://hell/test.txt</span></span><br><span class="line">        <span class="comment">//构造方法2</span></span><br><span class="line">        InputStream inputStream2 = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;f://hello/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  一次读取一个字节数组</span></span><br><span class="line">        <span class="keyword">while</span> ((i2 = inputStream2.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(b, <span class="number">0</span>, i2) + <span class="string">&quot; &quot;</span>);<span class="comment">// AB CD</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭IO流</span></span><br><span class="line">        inputStream2.close();</span><br></pre></td></tr></table></figure><blockquote><p>注： 一次读取一个字节数组，提高了操作效率,IO流使用完毕一定要关闭。</p></blockquote><p>​      2）FileOutputStream</p><blockquote><p>FileOutputStream：字节文件输出流是用于将数据写入到File，从程序中写入到其他位置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">    <span class="comment">// 创建一个向指定File对象表示的文件中写入数据的文件输出流</span></span><br><span class="line">    FileOutputStream(File file)</span><br><span class="line">    <span class="comment">// 创建一个向指定File对象表示的文件中写入数据的文件输出流</span></span><br><span class="line">    FileOutputStream(File file, <span class="keyword">boolean</span> append)</span><br><span class="line">    <span class="comment">// 创建一个向具有指定名称的文件中写入数据的输出文件流</span></span><br><span class="line">    FileOutputStream(String name)</span><br><span class="line">    <span class="comment">// 创建一个向具有指定name的文件中写入数据的输出文件流</span></span><br><span class="line">    FileOutputStream(String name, <span class="keyword">boolean</span> append)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">outputStream.write(<span class="string">&quot;ABCD&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 关闭IO流</span></span><br><span class="line">outputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内容追加写入</span></span><br><span class="line">OutputStream outputStream2 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 输出换行符</span></span><br><span class="line">outputStream2.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 输出追加内容</span></span><br><span class="line">outputStream2.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 关闭IO流</span></span><br><span class="line">outputStream2.close();</span><br></pre></td></tr></table></figure><blockquote><p>注；输出的目的地文件不存在，则会自动创建，不指定盘符的话，默认创建在项目目录下;输出换行符时一定要写\r\n不能只写\n,因为不同文本编辑器对换行符的识别存在差异性。</p></blockquote><ol start="3"><li>字节缓冲流（高效流）</li></ol><p>​      1）BufferedInputStream</p><blockquote><p>BufferedInputStream：字节缓冲输入流，提高了读取效率。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">     <span class="comment">// 创建一个 BufferedInputStream并保存其参数，即输入流in，以便将来使用。</span></span><br><span class="line">     BufferedInputStream(InputStream in)</span><br><span class="line">     <span class="comment">// 创建具有指定缓冲区大小的 BufferedInputStream并保存其参数，即输入流in以便将来使用</span></span><br><span class="line">     BufferedInputStream(InputStream in, <span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 字节缓存流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = bis.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</span><br><span class="line">    <span class="comment">// ABCD</span></span><br><span class="line">    <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">bis.close();</span><br></pre></td></tr></table></figure><p>​      2）BufferedOutputStream</p><blockquote><p>BufferedOutputStream：字节缓冲输出流，提高了写出效率。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">     <span class="comment">// 创建一个新的缓冲输出流，以将数据写入指定的底层输出流</span></span><br><span class="line">     BufferedOutputStream(OutputStream out)</span><br><span class="line">     <span class="comment">// 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流</span></span><br><span class="line">     BufferedOutputStream(OutputStream out, <span class="keyword">int</span> size)</span><br><span class="line"></span><br><span class="line">     常用方法：</span><br><span class="line">     <span class="comment">// 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">     <span class="comment">// 将指定的字节写入此缓冲的输出流</span></span></span><br><span class="line"><span class="function">     <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">     <span class="comment">// 刷新此缓冲的输出流</span></span></span><br><span class="line"><span class="function">     <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>, <span class="keyword">true</span>));</span><br><span class="line"><span class="comment">// 输出换行符</span></span><br><span class="line">bos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 输出内容</span></span><br><span class="line">bos.write(<span class="string">&quot;Hello Android&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 刷新此缓冲的输出流</span></span><br><span class="line">bos.flush();</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ol><li>字符流基类</li></ol><p>​      1）Reader</p><blockquote><p>Reader:读取字符流的抽象类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法：</span></span><br><span class="line">    <span class="comment">// 读取单个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将字符读入数组</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将字符读入数组的某一部分</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 跳过字符</span></span></span><br><span class="line"><span class="function">    <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 关闭该流并释放与之关联的所有资源</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>​      2）Writer</p><blockquote><p>Writer:写入字符流的抽象类.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法：</span></span><br><span class="line">    <span class="comment">// 写入字符数组</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 写入字符数组的某一部分</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 写入单个字符</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 写入字符串</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 写入字符串的某一部分</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 将指定字符添加到此 writer</span></span></span><br><span class="line"><span class="function">    Writer <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将指定字符序列添加到此 writer</span></span></span><br><span class="line"><span class="function">    Writer <span class="title">append</span><span class="params">(CharSequence csq)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将指定字符序列的子序列添加到此 writer.Appendable</span></span></span><br><span class="line"><span class="function">    Writer <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 关闭此流，但要先刷新它</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 刷新该流的缓冲</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>字符转换流</li></ol><p>​      1）InputStreamReader</p><blockquote><p>InputStreamReader：字节流转字符流，它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">    <span class="comment">// 创建一个使用默认字符集的 InputStreamReader</span></span><br><span class="line">    InputStreamReader(InputStream in)</span><br><span class="line">    <span class="comment">// 创建使用给定字符集的 InputStreamReader</span></span><br><span class="line">    InputStreamReader(InputStream in, Charset cs)</span><br><span class="line">    <span class="comment">// 创建使用给定字符集解码器的 InputStreamReader</span></span><br><span class="line">    InputStreamReader(InputStream in, CharsetDecoder dec)</span><br><span class="line">    <span class="comment">// 创建使用指定字符集的 InputStreamReader</span></span><br><span class="line">    InputStreamReader(InputStream in, String charsetName)</span><br><span class="line"> <span class="comment">//特有方法：</span></span><br><span class="line">    <span class="comment">//返回此流使用的字符编码的名称 </span></span><br><span class="line">    <span class="function">String <span class="title">getEncoding</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认编码        </span></span><br><span class="line">      InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">      <span class="keyword">while</span> ((len = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>) len);<span class="comment">//爱生活，爱Android</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      reader.close();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//指定编码 </span></span><br><span class="line">      InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">      <span class="keyword">while</span> ((len = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>) len);<span class="comment">//????????Android</span></span><br><span class="line">      &#125;</span><br><span class="line">      reader.close();</span><br></pre></td></tr></table></figure><blockquote><p>注：Eclipse默认使用GBK编码,test.txt文件所以是GBK编码，当指定utf-8编码时所以会乱码。</p></blockquote><p>​      2）OutputStreamWriter</p><blockquote><p>OutputStreamWriter：字节流转字符流。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">    <span class="comment">// 创建使用默认字符编码的 OutputStreamWriter</span></span><br><span class="line">    OutputStreamWriter(OutputStream out)</span><br><span class="line">    <span class="comment">// 创建使用给定字符集的 OutputStreamWriter</span></span><br><span class="line">    OutputStreamWriter(OutputStream out, Charset cs)</span><br><span class="line">    <span class="comment">// 创建使用给定字符集编码器的 OutputStreamWriter</span></span><br><span class="line">    OutputStreamWriter(OutputStream out, CharsetEncoder enc)</span><br><span class="line">    <span class="comment">// 创建使用指定字符集的 OutputStreamWriter</span></span><br><span class="line">    OutputStreamWriter(OutputStream out, String charsetName)</span><br><span class="line"> <span class="comment">//特有方法：</span></span><br><span class="line">    <span class="comment">//返回此流使用的字符编码的名称 </span></span><br><span class="line">    <span class="function">String <span class="title">getEncoding</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><ol start="3"><li>字符缓冲流（高效流）</li></ol><p>​      1）BufferedReader</p><blockquote><p>BufferedReader：字符缓冲流，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">    <span class="comment">// 创建一个使用默认大小输入缓冲区的缓冲字符输入流</span></span><br><span class="line">    BufferedReader(Reader in)</span><br><span class="line">    <span class="comment">// 创建一个使用指定大小输入缓冲区的缓冲字符输入流</span></span><br><span class="line">    BufferedReader(Reader in, <span class="keyword">int</span> sz)</span><br><span class="line"> <span class="comment">//特有方法：</span></span><br><span class="line">    <span class="comment">// 读取一个文本行</span></span><br><span class="line">    <span class="function">String <span class="title">readLine</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成字符缓冲流对象</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">String str;</span><br><span class="line"><span class="comment">//一次性读取一行</span></span><br><span class="line"><span class="keyword">while</span> ((str = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(str);<span class="comment">// 爱生活，爱Android</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><p>​      2）BufferedWriter</p><blockquote><p>BufferedWriter：字符缓冲流，将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">    <span class="comment">// 创建一个使用默认大小输出缓冲区的缓冲字符输出流</span></span><br><span class="line">    BufferedWriter(Writer out)</span><br><span class="line">    <span class="comment">// 创建一个使用给定大小输出缓冲区的新缓冲字符输出流</span></span><br><span class="line">    BufferedWriter(Writer out, <span class="keyword">int</span> sz)</span><br><span class="line"> <span class="comment">//特有方法：</span></span><br><span class="line">    <span class="comment">// 写入一个行分隔符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><ol start="4"><li>FileReader、FileWriter</li></ol><p>​      1）FileReader：InputStreamReader类的直接子类，用来读取字符文件的便捷类，使用默认字符编码。<br>​      2）FileWriter：OutputStreamWriter类的直接子类，用来写入字符文件的便捷类，使用默认字符编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="创建" scheme="https://blog.yongkj.cn/tags/%E5%88%9B%E5%BB%BA/"/>
    
    <category term="传输" scheme="https://blog.yongkj.cn/tags/%E4%BC%A0%E8%BE%93/"/>
    
    <category term="读取" scheme="https://blog.yongkj.cn/tags/%E8%AF%BB%E5%8F%96/"/>
    
    <category term="输出" scheme="https://blog.yongkj.cn/tags/%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>类加载</title>
    <link href="https://blog.yongkj.cn/2021/02/08/java-class-loading/"/>
    <id>https://blog.yongkj.cn/2021/02/08/java-class-loading/</id>
    <published>2021-02-08T12:59:52.000Z</published>
    <updated>2021-02-10T08:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。</li></ol><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>加载</li></ol><p>​      1）加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。</p><p>​      2）类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</p><p>​      3）通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</p><ul><li>从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。</li><li>从JAR包加载class文件，这种方式也是很常见的，JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。</li><li>通过网络加载class文件。</li><li>把一个Java源文件动态编译，并执行加载。</li></ul><blockquote><p>类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。</p></blockquote><ol start="2"><li>链接</li></ol><blockquote><p>当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。</p></blockquote><p>​      1）<strong>验证：</strong>验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><blockquote><p>四种验证做进一步说明：</p><p><strong>文件格式验证：</strong>主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。</p><p>  <strong>元数据验证：</strong>对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。</p><p>  <strong>字节码验证：</strong>最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。</p><p>  <strong>符号引用验证：</strong>主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。</p></blockquote><p>​      2）<strong>准备：</strong>类准备阶段负责为类的静态变量分配内存，并设置默认初始值。</p><p>​      3）<strong>解析：</strong>将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。</p><ol start="3"><li>初始化</li></ol><p>​      1）初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><ol><li>创建类的实例，也就是new一个对象</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（Class.forName(“com.lyj.load”)）</li><li>初始化一个类的子类（会首先初始化子类的父类）</li><li>JVM启动时标明的启动类，即文件名和类名相同的那个类 </li></ol><blockquote><p><strong>除此之外，下面几种情形需要特别指出：</strong></p><p>   对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p></blockquote><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。</p><p>  JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：</p></blockquote><ol><li><strong>根类加载器</strong>（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li></ol><blockquote><p>下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urls)&#123;</span><br><span class="line">System.out.println(url.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>扩展类加载器</strong>（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。</p></li><li><p><strong>系统类加载器</strong>（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。</p></li></ol><blockquote><p>类加载器加载Class大致要经过如下8个步骤：</p><ol><li>检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。</li><li>如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。</li><li>请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。</li><li>请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。</li><li>当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。</li><li>从文件中载入Class，成功后跳至第8步。</li><li>抛出ClassNotFountException异常。</li><li>返回对应的java.lang.Class对象。</li></ol></blockquote><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ol><li>JVM的类加载机制主要有如下3种</li></ol><p>​      1）全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><p>​      2）双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</p><p>​      3）缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p><ol start="2"><li>这里说明一下双亲委派机制：</li></ol><p><img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E7%B1%BB%E5%8A%A0%E8%BD%BD/20180813145521896.png" alt="20180813145521896.png"></p><p>​      1）双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。</p><p>​      2）双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="加载" scheme="https://blog.yongkj.cn/tags/%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="验证" scheme="https://blog.yongkj.cn/tags/%E9%AA%8C%E8%AF%81/"/>
    
    <category term="创建" scheme="https://blog.yongkj.cn/tags/%E5%88%9B%E5%BB%BA/"/>
    
    <category term="检测" scheme="https://blog.yongkj.cn/tags/%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="https://blog.yongkj.cn/2021/02/07/java-annotation/"/>
    <id>https://blog.yongkj.cn/2021/02/07/java-annotation/</id>
    <published>2021-02-07T13:00:52.000Z</published>
    <updated>2021-02-10T08:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h3><ol><li>注解（Annotation），也叫元数据（Metadata），是Java5的新特性，JDK5引入了Metadata很容易的就能够调用Annotations。注解与类、接口、枚举在同一个层次，并可以应用于包、类型、构造方法、方法、成员变量、参数、本地变量的声明中，用来对这些元素进行说明注释。</li></ol><h3 id="注解的语法与定义形式"><a href="#注解的语法与定义形式" class="headerlink" title="注解的语法与定义形式"></a>注解的语法与定义形式</h3><ol><li>以@interface关键字定义</li><li>注解包含成员，成员以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型。</li><li>成员赋值是通过@Annotation(name=value)的形式。</li><li>注解需要标明注解的生命周期，注解的修饰目标等信息，这些信息是通过元注解实现。</li></ol><blockquote><p>以 <strong>java.lang.annotation</strong> 中定义的 <strong>Target</strong> 注解来说明：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123; ElementType.ANNOTATION_TYPE &#125; )</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>源码分析如下：<br>第一：元注解@Retention，成员value的值为RetentionPolicy.RUNTIME。<br>第二：元注解@Target，成员value是个数组，用{}形式赋值，值为ElementType.ANNOTATION_TYPE<br>第三：成员名称为value，类型为ElementType[]<br>另外，需要注意一下，如果成员名称是value，在赋值过程中可以简写。如果成员类型为数组，但是只赋值一个元素，则也可以简写。如上面的简写形式为：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><blockquote><p>注解的分类有两种分法：</p></blockquote><ol><li>第一种分法</li></ol><p>​      1）基本内置注解，是指Java自带的几个Annotation，如@Override、Deprecated、@SuppressWarnings等；</p><p>​      2）元注解（meta-annotation），是指负责注解其他注解的注解，JDK 1.5及以后版本定义了4个标准的元注解类型，如下：</p><ul><li>@Target</li><li>@Retention</li><li>@Documented</li><li>@Inherited</li></ul><p>​      3）自定义注解，根据需要可以自定义注解，自定义注解需要用到上面的meta-annotation</p><ol start="2"><li>第二种分法，根据作用域分类</li></ol><p>​      1）源码时注解（RetentionPolicy.SOURCE）<br>​      2）编译时注解（RetentionPolicy.CLASS）<br>​      3）运行时注解（RetentionPolicy.RUNTIME）</p><blockquote><p>注解需要标明注解的生命周期，这些信息是通过元注解 <strong>@Retention</strong> 实现，注解的值是 <strong>enum</strong> 类型的 <strong>RetentionPolicy</strong>，包括以下几种情况：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃.</span></span><br><span class="line"><span class="comment">     * 这意味着：Annotation仅存在于编译器处理期间，编译器处理完之后，该Annotation就没用了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，</span></span><br><span class="line"><span class="comment">     * 保存到class对象中，可以通过反射来获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote><p>如上所介绍的Java定义了4个标准的元注解：</p></blockquote><ol><li>@Documented：标记注解，用于描述其它类型的注解应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Inherited：标记注解，允许子类继承父类的注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Retention：指Annotation被保留的时间长短，标明注解的生命周期，3种<strong>RetentionPolicy</strong>取值含义上面以说明</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>@Target：标明注解的修饰目标，共有</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ElementType取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 类、接口（包括注解类型）或枚举 */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** field属性，也包括enum常量使用的注解 */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">/** 方法 */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">/** 参数 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** 构造函数 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">/** 局部变量 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">/** 注解上使用的元注解 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">/** 包 */</span></span><br><span class="line">    PACKAGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用反射API读取注解"><a href="#使用反射API读取注解" class="headerlink" title="使用反射API读取注解"></a>使用反射API读取注解</h3><ol><li>MyAnno自定义注解类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;猿同学&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;猿同学&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;<span class="comment">//用户不存在</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>POJO类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnno(&quot;java&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnno(id=20)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@MyAnno(name=&quot;java&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@MyAnno(age=20)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>利用反射读取注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnoReflat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class cls = Class.forName(<span class="string">&quot;com.sc.domain.User&quot;</span>);</span><br><span class="line">        MyAnno annotation = (MyAnno) cls.getDeclaredAnnotation(MyAnno.class);</span><br><span class="line">        System.out.println(annotation.value());</span><br><span class="line"></span><br><span class="line">        MyAnno name = cls.getDeclaredField(<span class="string">&quot;name&quot;</span>).getAnnotation(MyAnno.class);</span><br><span class="line">        System.out.println(name.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="参数" scheme="https://blog.yongkj.cn/tags/%E5%8F%82%E6%95%B0/"/>
    
    <category term="类型" scheme="https://blog.yongkj.cn/tags/%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="周期" scheme="https://blog.yongkj.cn/tags/%E5%91%A8%E6%9C%9F/"/>
    
    <category term="继承" scheme="https://blog.yongkj.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://blog.yongkj.cn/2021/02/06/java-reflect/"/>
    <id>https://blog.yongkj.cn/2021/02/06/java-reflect/</id>
    <published>2021-02-06T12:58:52.000Z</published>
    <updated>2021-02-10T08:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="什么叫java反射"><a href="#什么叫java反射" class="headerlink" title="什么叫java反射"></a>什么叫java反射</h3><ol><li><p>Java反射是Java被视为动态（或准动态）语言的一个关键性质。</p></li><li><p>这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public, static 等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。</p></li><li><p>Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。</p></li><li><p>换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。</p></li></ol><h3 id="为什么要使用反射"><a href="#为什么要使用反射" class="headerlink" title="为什么要使用反射"></a>为什么要使用反射</h3><ol><li>如果正常实例化去一个对象，去调用它的任意方法或者属性跟通过反射去实例化一个对象到底有什么区别呢？</li><li>其实在编译阶段是没有任何区别，但是根据反射的定义：反射的重点是在于运行阶段来获取类的信息，因为在编译阶段有部分的信息是不清晰的，需要在运行的阶段去加载的。</li><li>简单来说：在编译阶段不知道需要实例化哪个对象，需要在运行阶段去从配置文件去加载，或者在运行阶段，需要临时访问类的信息。</li></ol><h3 id="反射API"><a href="#反射API" class="headerlink" title="反射API"></a>反射API</h3><ol><li>java.lang.Class 反射的核心，可以获取类的属性，方法等等</li><li>java.lang.reflect.Constructor 类的构造方法</li><li>java.lang.reflect.Field 类的成员变量，可以用来获取和设置类之中的属性值</li><li>java.lang.reflect.Method 类的方法，可以获取类中的方法信息</li><li>java.lang.reflect.Modifier 类的访问权限</li></ol><blockquote><p>Java反射相关的API在包java.lang.reflect中，JDK 1.6.0的reflect包如下图</p></blockquote><table><thead><tr><th>Member接口</th><th>该接口可以获取有关类成员（域或者方法）后者构造函数的信息。</th></tr></thead><tbody><tr><td>AccessibleObject类</td><td>该类是域(field)对象、方法(method)对象、构造函数(constructor)对象的基础类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。</td></tr><tr><td>Array类</td><td>该类提供动态地生成和访问JAVA数组的方法。</td></tr><tr><td>Constructor类</td><td>提供一个类的构造函数的信息以及访问类的构造函数的接口。</td></tr><tr><td>Field类</td><td>提供一个类的域的信息以及访问类的域的接口。</td></tr><tr><td>Method类</td><td>提供一个类的方法的信息以及访问类的方法的接口。</td></tr><tr><td>Modifier类</td><td>提供了 static 方法和常量，对类和成员访问修饰符进行解码。</td></tr><tr><td>Proxy类</td><td>提供动态地生成代理类和类实例的静态方法。</td></tr></tbody></table><h3 id="JAVA反射机制提供了什么功能"><a href="#JAVA反射机制提供了什么功能" class="headerlink" title="JAVA反射机制提供了什么功能"></a>JAVA反射机制提供了什么功能</h3><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判段任意一个类所具有的成员变量和方法</li><li>在运行时调用任一个对象的方法</li><li>在运行时创建新类对象</li><li>在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。</li></ol><h3 id="使用反射的步骤"><a href="#使用反射的步骤" class="headerlink" title="使用反射的步骤"></a>使用反射的步骤</h3><ol><li>获取想要的类的class对象</li><li>调用类中的方法</li><li>使用反射API来操作这些信息</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> pubIntField;</span><br><span class="line"><span class="keyword">public</span> String pubStringField;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> prvIntField;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log(<span class="string">&quot;Default Constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Type(<span class="keyword">int</span> arg1, String arg2)&#123;</span><br><span class="line">pubIntField = arg1;</span><br><span class="line">pubStringField = arg2;</span><br><span class="line"></span><br><span class="line">Log(<span class="string">&quot;Constructor with parameters&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntField</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.prvIntField = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> prvIntField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Type:&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendType</span> <span class="keyword">extends</span> <span class="title">Type</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> pubIntExtendField;</span><br><span class="line"><span class="keyword">public</span> String pubStringExtendField;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> prvIntExtendField;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtendType</span><span class="params">()</span></span>&#123;</span><br><span class="line">Log(<span class="string">&quot;Default Constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExtendType(<span class="keyword">int</span> arg1, String arg2)&#123;</span><br><span class="line">pubIntExtendField = arg1;</span><br><span class="line">pubStringExtendField = arg2;</span><br><span class="line"></span><br><span class="line">Log(<span class="string">&quot;Constructor with parameters&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntExtendField</span><span class="params">(<span class="keyword">int</span> field7)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.prvIntExtendField = field7;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntExtendField</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> prvIntExtendField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ExtendType:&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取类的Class对象</li></ol><blockquote><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。获取类的Class对象有多种方式：</p></blockquote><table><thead><tr><th>方法调用</th><th>结果</th></tr></thead><tbody><tr><td>调用getClass</td><td>Boolean var1 = true;Class&lt;?&gt; classType2 = var1.getClass();System.out.println(classType2);输出：class java.lang.Boolean</td></tr><tr><td>运用.class 语法</td><td>Class&lt;?&gt; classType4 = Boolean.class;System.out.println(classType4);输出：class java.lang.Boolean</td></tr><tr><td>运用static method Class.forName()</td><td>Class&lt;?&gt; classType5 = Class.forName(“java.lang.Boolean”);System.out.println(classType5);输出：class java.lang.Boolean</td></tr><tr><td>运用primitive wrapper classes的TYPE 语法这里返回的是原生类型，和Boolean.class返回的不同</td><td>Class&lt;?&gt; classType3 = Boolean.TYPE;System.out.println(classType3);    输出：boolean</td></tr></tbody></table><ol start="2"><li>获取类的Fields</li></ol><blockquote><p>可以通过反射机制得到某个类的某个属性，然后改变对应于这个类的某个实例的该属性值。JAVA 的Class<T>类提供了几个方法获取类的属性。</p></blockquote><table><thead><tr><th>方法调用</th><th>结果</th></tr></thead><tbody><tr><td>public Field getField(String name)</td><td>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段</td></tr><tr><td>public Field[] getFields()</td><td>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段</td></tr><tr><td>public Field getDeclaredField(String name)</td><td>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段</td></tr><tr><td>public Field[] getDeclaredFields()</td><td>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = ExtendType.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getFields获取属性</span></span><br><span class="line">Field[] fields = classType.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : fields)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getDeclaredFields获取属性</span></span><br><span class="line">fields = classType.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : fields)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int com.quincy.ExtendType.pubIntExtendField</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public java.lang.String com.quincy.ExtendType.pubStringExtendField</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int com.quincy.Type.pubIntField</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public java.lang.String com.quincy.Type.pubStringField</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int com.quincy.ExtendType.pubIntExtendField</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public java.lang.String com.quincy.ExtendType.pubStringExtendField</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">private int com.quincy.ExtendType.prvIntExtendField</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>可见getFields和getDeclaredFields区别：</p><p>getFields返回的是申明为public的属性，包括父类中定义，</p><p>getDeclaredFields返回的是指定类定义的所有定义的属性，不包括父类的。</p></blockquote><ol start="3"><li>获取类的Method</li></ol><blockquote><p>通过反射机制得到某个类的某个方法，然后调用对应于这个类的某个实例的该方法</p><p>Class<T>类提供了几个方法获取类的方法。</p></blockquote><table><thead><tr><th>方法调用</th><th>结果</th></tr></thead><tbody><tr><td>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法</td></tr><tr><td>public Method[] getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法</td></tr><tr><td>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法</td></tr><tr><td>public Method[] getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用getMethods获取函数 </span></span><br><span class="line">Class&lt;?&gt; classType = ExtendType.class;</span><br><span class="line">Method[] methods = classType.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method m : methods)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getDeclaredMethods获取函数 </span></span><br><span class="line">methods = classType.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method m : methods)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void com.quincy.ExtendType.setIntExtendField(int)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int com.quincy.ExtendType.getIntExtendField()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void com.quincy.Type.setIntField(int)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int com.quincy.Type.getIntField()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public java.lang.String java.lang.Object.toString()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">private void com.quincy.ExtendType.Log(java.lang.String)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void com.quincy.ExtendType.setIntExtendField(int)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public int com.quincy.ExtendType.getIntExtendField()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获取类的Constructor</li></ol><blockquote><p>通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例 </p><p>Class<T>类提供了几个方法获取类的构造器。</p></blockquote><table><thead><tr><th>方法调用</th><th>结果</th></tr></thead><tbody><tr><td>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法</td></tr><tr><td>public Constructor&lt;?&gt;[] getConstructors()</td><td>返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法</td></tr><tr><td>public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法</td></tr><tr><td>public Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td>返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用getConstructors获取构造器  </span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = classType.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; m : constructors)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getDeclaredConstructors获取构造器   </span></span><br><span class="line">constructors = classType.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; m : constructors)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">public com.quincy.ExtendType()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public com.quincy.ExtendType()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">com.quincy.ExtendType(int,java.lang.String)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="5"><li>新建类的实例</li></ol><blockquote><p>通过反射机制创建新类的实例，有几种方法可以创建</p></blockquote><table><thead><tr><th>方法调用</th><th>结果</th></tr></thead><tbody><tr><td>调用无自变量ctor</td><td>1、调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败.Class<?> classType = ExtendType.class;Object inst = classType.newInstance();System.out.println(inst);输出：Type:Default ConstructorExtendType:Default Constructorcom.quincy.ExtendType@d80be3 2、调用默认Constructor对象的newInstance方法Class<?> classType = ExtendType.class;Constructor&lt;?&gt; constructor1 = classType.getConstructor();Object inst = constructor1.newInstance();System.out.println(inst);输出：Type:Default ConstructorExtendType:Default Constructorcom.quincy.ExtendType@1006d75</td></tr><tr><td>调用带参数ctor</td><td><strong>3、调用带参数Constructor对象的newInstance方法</strong>Constructor&lt;?&gt; constructor2 =classType.getDeclaredConstructor(int.class, String.class);Object inst = constructor2.newInstance(1, “123”);System.out.println(inst);输出：Type:Default ConstructorExtendType:Constructor with parameterscom.quincy.ExtendType@15e83f9</td></tr></tbody></table><ol start="6"><li>调用类的函数</li></ol><blockquote><p>通过反射获取类Method对象，调用Field的Invoke方法调用函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = ExtendType.class;</span><br><span class="line">Object inst = classType.newInstance();</span><br><span class="line">Method logMethod = classType.getDeclaredMethod(<span class="string">&quot;Log&quot;</span>, String.class);</span><br><span class="line">logMethod.invoke(inst, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Type:Default Constructor</span><br><span class="line">ExtendType:Default Constructor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType = ExtendType.class;</span><br><span class="line">Object inst = classType.newInstance();</span><br><span class="line">Method logMethod = classType.getDeclaredMethod(<span class="string">&quot;Log&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">logMethod.invoke(inst, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="7"><li>设置/获取类的属性值</li></ol><blockquote><p>通过反射获取类的Field对象，调用Field方法设置或获取值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = ExtendType.class;</span><br><span class="line">Object inst = classType.newInstance();</span><br><span class="line">Field intField = classType.getField(<span class="string">&quot;pubIntExtendField&quot;</span>);</span><br><span class="line">intField.setInt(inst, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> value = intField.getInt(inst);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="实例" scheme="https://blog.yongkj.cn/tags/%E5%AE%9E%E4%BE%8B/"/>
    
    <category term="动态" scheme="https://blog.yongkj.cn/tags/%E5%8A%A8%E6%80%81/"/>
    
    <category term="构造" scheme="https://blog.yongkj.cn/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="获取" scheme="https://blog.yongkj.cn/tags/%E8%8E%B7%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>框架注解</title>
    <link href="https://blog.yongkj.cn/2021/02/05/java-framework-annotations/"/>
    <id>https://blog.yongkj.cn/2021/02/05/java-framework-annotations/</id>
    <published>2021-02-05T12:56:52.000Z</published>
    <updated>2021-02-10T08:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="SpringBoot之常用注解"><a href="#SpringBoot之常用注解" class="headerlink" title="SpringBoot之常用注解"></a>SpringBoot之常用注解</h3><blockquote><p>在spring boot中，摒弃了spring以往项目中大量繁琐的配置，遵循约定大于配置的原则，通过自身默认配置，极大的降低了项目搭建的复杂度。同样在spring boot中，大量注解的使用，使得代码看起来更加简洁，提高开发的效率。这些注解不光包括spring boot自有，也有一些是继承自spring的。</p></blockquote><ol><li>项目配置注解</li></ol><p>​      1）@SpringBootApplication 注解</p><blockquote><p>@SpringBootApplication是一个复合注解，包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解。</p></blockquote><ul><li><p>@SpringBootConfiguration:标注当前类是配置类，这个注解继承自@Configuration。并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。</p></li><li><p>@EnableAutoConfiguration:是自动配置的注解，这个注解会根据我们添加的组件jar来完成一些默认配置，我们做微服时会添加spring-boot-starter-web这个组件jar的pom依赖，这样配置会默认配置springmvc 和tomcat。</p></li><li><p>@ComponentScan:扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。等价于<a href="context:component-scan">context:component-scan</a>的xml配置文件中的配置项。</p><blockquote><p>大多数情况下，这3个注解会被同时使用，基于最佳实践，这三个注解就被做了包装，成为了@SpringBootApplication注解</p></blockquote></li></ul><p>​      2）@ServletComponentScan 注解</p><ul><li>Servlet、Filter、Listener 可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，这样通过注解servlet ，拦截器，监听器的功能而无需其他配置，所以这次相中使用到了filter的实现，用到了这个注解</li></ul><p>​      3）@MapperScan注解</p><ul><li>spring-boot支持mybatis组件的一个注解，通过此注解指定mybatis接口类的路径，即可完成对mybatis接口的扫描</li><li>它和@mapper注解是一样的作用，不同的地方是扫描入口不一样。@mapper需要加在每一个mapper接口类上面。所以大多数情况下，都是在规划好工程目录之后，通过@MapperScan注解配置路径完成mapper接口的注入。</li><li>添加mybatis相应组建依赖之后。就可以使用该注解。</li></ul><p>​      4）资源导入注解</p><ul><li><p>@ImportResource @Import @PropertySource 这三个注解都是用来导入自定义的一些配置文件。</p></li><li><p>@ImportResource(locations={}) 导入其他xml配置文件，需要标准在主配置类上。</p></li><li><p>导入property的配置文件 @PropertySource指定文件路径，这个相当于使用spring的<importresource/>标签来完成配置项的引入。</p></li><li><p>@import注解是一个可以将普通类导入到spring容器中做管理</p></li></ul><ol start="2"><li>controller 层</li></ol><p>​      1）@Controller注解</p><ul><li><p>@Controller 表明这个类是一个控制器类，和@RequestMapping来配合使用拦截请求，如果不在method中注明请求的方式，默认是拦截get和post请求。这样请求会完成后转向一个视图解析器。但是在大多微服务搭建的时候，前后端会做分离。所以请求后端只关注数据处理，后端返回json数据的话，需要配合@ResponseBody注解来完成。</p></li><li><p>这样一个只需要返回数据的接口就需要3个注解来完成，大多情况我们都是需要返回数据。也是基于最佳实践，所以将这三个注解进一步整合。</p></li><li><p>@RestController 是@Controller 和@ResponseBody的结合，一个类被加上@RestController 注解，数据接口中就不再需要添加@ResponseBody。更加简洁。</p></li><li><p>同样的情况,@RequestMapping(value=””,method= RequestMethod.GET ),我们都需要明确请求方式。这样的写法又会显得比较繁琐，于是乎就有了如下的几个注解。</p></li></ul><table><thead><tr><th>普通风格</th><th>Rest风格</th></tr></thead><tbody><tr><td>@RequestMapping(value=“”,method = RequestMethod.GET)</td><td>@GetMapping(value =“”)</td></tr><tr><td>@RequestMapping(value=“”,method = RequestMethod.POST)</td><td>@PostMapping(value =“”)</td></tr><tr><td>@RequestMapping(value=“”,method = RequestMethod.PUT)</td><td>@PutMapping(value =“”)</td></tr><tr><td>@RequestMapping(value=“”,method = RequestMethod.DELETE)</td><td>@DeleteMapping(value =“”)</td></tr></tbody></table><blockquote><p>这几个注解是 @RequestMapping(value=””,method= RequestMethod.xxx )的最佳实践。为了代码的更加简洁。</p></blockquote><p>​      2）@CrossOrigin 注解</p><ul><li><p>@CrossOrigin(origins = “”, maxAge = 1000) 这个注解主要是为了解决跨域访问的问题。这个注解可以为整个controller配置启用跨域，也可以在方法级别启用。</p></li><li><p>我们在项目中使用这个注解是为了解决微服在做定时任务调度编排的时候，会访问不同的spider节点而出现跨域问题。</p></li></ul><p>​      3）@Autowired 注解</p><ul><li>这是个最熟悉的注解，是spring的自动装配，这个个注解可以用到构造器，变量域，方法，注解类型上。当我们需要从bean 工厂中获取一个bean时，Spring会自动为我们装配该bean中标记为@Autowired的元素。</li></ul><p>​      4）@EnableCaching 注解</p><ul><li>个注解是spring framework中的注解驱动的缓存管理功能。自spring版本3.1起加入了该注解。其作用相当于spring配置文件中的cache manager标签。</li></ul><p>​      5）@PathVariable 注解</p><ul><li>路径变量注解，@RequestMapping中用{}来定义url部分的变量名</li></ul><ol start="3"><li>servcie层注解</li></ol><p>​      1）@Service</p><ul><li>这个注解用来标记业务层的组件，我们会将业务逻辑处理的类都会加上这个注解交给spring容器。事务的切面也会配置在这一层。当让 这个注解不是一定要用。有个泛指组件的注解，当我们不能确定具体作用的时候 可以用泛指组件的注解托付给spring容器。</li></ul><p>​      2）@Resource</p><ul><li><p>@Resource和@Autowired一样都可以用来装配bean，都可以标注字段上，或者方法上。 @resource注解不是spring提供的，是属于J2EE规范的注解。</p></li><li><p>两个之前的区别就是匹配方式上有点不同，@Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配。</p></li></ul><ol start="4"><li>持久层注解</li></ol><p>​      1）@Repository</p><ul><li><p>@Repository注解类作为DAO对象，管理操作数据库的对象。</p></li><li><p>总得来看，@Component, @Service, @Controller, @Repository是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理</p></li><li><p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能。</p></li><li><p>通过这些注解的分层管理，就能将请求处理，义务逻辑处理，数据库操作处理分离出来，为代码解耦，也方便了以后项目的维护和开发。</p></li><li><p>所以我们在正常开发中，如果能用@Service, @Controller, @Repository其中一个标注这个类的定位的时候，就不要用@Component来标注。</p></li></ul><p>​      2）@Transactional</p><ul><li><p>通过这个注解可以声明事务，可以添加在类上或者方法上。</p></li><li><p>在spring boot中 不用再单独配置事务管理，一般情况是我们会在servcie层添加了事务注解，即可开启事务。要注意的是，事务的开启只能在public 方法上。并且主要事务切面的回滚条件。正常我们配置rollbackfor exception时 ，如果在方法里捕获了异常就会导致事务切面配置的失效。</p></li></ul><ol start="5"><li>其他相关注解</li></ol><ul><li><p>@ControllerAdvice 和 @RestControllerAdvice：通常和@ExceptionHandler、@InitBinder、@ModelAttribute一起配合使用。</p></li><li><p>@ControllerAdvice 和 @ExceptionHandler 配合完成统一异常拦截处理。</p></li><li><p>@RestControllerAdvice 是 @ControllerAdvice 和 @ResponseBody的合集，可以将异常以json的格式返回数据。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="配置" scheme="https://blog.yongkj.cn/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="组件" scheme="https://blog.yongkj.cn/tags/%E7%BB%84%E4%BB%B6/"/>
    
    <category term="扫描" scheme="https://blog.yongkj.cn/tags/%E6%89%AB%E6%8F%8F/"/>
    
    <category term="容器" scheme="https://blog.yongkj.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="https://blog.yongkj.cn/2021/02/04/java-basic-knowledge/"/>
    <id>https://blog.yongkj.cn/2021/02/04/java-basic-knowledge/</id>
    <published>2021-02-04T12:50:52.000Z</published>
    <updated>2021-02-10T08:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h3><ol><li>关于Java的8种基本数据类型，其名称、位数、默认值、取值范围及示例如下表所示：</li></ol><table><thead><tr><th>序号</th><th>数据类型</th><th>位数</th><th>默认值</th><th>取值范围</th><th>举例说明</th></tr></thead><tbody><tr><td>1</td><td>byte(位)</td><td>8</td><td>0</td><td>-2^7 ~ +2^7-1</td><td>byte b = 10;</td></tr><tr><td>2</td><td>short(短整数)</td><td>16</td><td>0</td><td>-2^15 ~ +2^15-1</td><td>short s = 10;</td></tr><tr><td>3</td><td>int(整数)</td><td>32</td><td>0</td><td>-2^31 ~ +2^31-1</td><td>int i = 10;</td></tr><tr><td>4</td><td>long(长整数)</td><td>64</td><td>0</td><td>-2^63 ~ +2^63-1</td><td>long l = 10l;</td></tr><tr><td>5</td><td>float(单精度)</td><td>32</td><td>0.0</td><td>-2^128 ~ +2^127</td><td>float f = 10.0f;</td></tr><tr><td>6</td><td>double(双精度)</td><td>64</td><td>0.0</td><td>-2^1024 ~ +2^1023</td><td>double d = 10.0d;</td></tr><tr><td>7</td><td>char(字符)</td><td>16</td><td>空</td><td>0 ~ +2^16-1</td><td>char c = ‘c’;</td></tr><tr><td>8</td><td>boolean(布尔值)</td><td>8</td><td>false</td><td>true、false</td><td>boolean b = true;</td></tr></tbody></table><h3 id="自动装箱拆箱"><a href="#自动装箱拆箱" class="headerlink" title="自动装箱拆箱"></a>自动装箱拆箱</h3><ol><li>装箱就是自动将基本数据类型转换为包装器类型；</li><li>拆箱就是自动将包装器类型转换为基本数据类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer total = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> totalprim = total;</span><br></pre></td></tr></table></figure><h3 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals()和==的区别"></a>equals()和==的区别</h3><ol><li>equals是判断两个变量或者实例指向同一个内存空间的值是否相同</li><li>==是判断两个变量或者实例是不是指向同一个内存空间</li><li>==是判断两个人是不是住在同一个地址，而equals是判断同一个地址里住的人是不是同一个</li></ol><h3 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h3><ol><li>可变与不可变：String是不可变字符串对象，StringBuilder和StringBuffer是可变字符串对象（其内部的字符数组长度可变）。</li><li>是否多线程安全：String 是线程安全的。StringBuffer 也是线程安全的，而 StringBuilder 是非线程安全的。</li><li>String、StringBuilder、StringBuffer三者的执行效率：</li></ol><p>​      1）StringBuilder &gt; StringBuffer &gt; String</p><ol start="4"><li>应当根据不同的情况来进行选择使用：</li></ol><p>​      1）当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；</p><p>​      2）当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。</p><h3 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h3><ol><li>什么是字节流？</li></ol><p>​      1）传输数据的最基本单位是字节的流。</p><ol start="2"><li>什么是字符流？</li></ol><p>​      1）传输数据的最基本单位是字符的流。</p><ol start="3"><li>实现一个拷贝文件的类使用字节流还是字符流？</li></ol><p>​      1）字符类型一般包括：word、txt、文本类型。</p><p>​      2）字节类型一般包括：图片、声音、图像等。</p><p>​      3）因为一般字符流最终都要转换成字节流，所以为考虑到通用性，要用字节流。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ol><li>程序错误分为三种：编译错误；运行时错误；逻辑错误。</li></ol><p>​      1）编译错误：程序没有遵循语法规则，编译程序发现并提示错误的原因和位置。</p><p>​      2）运行时错误：程序在执行时，运行环境发现了不能执行的操作</p><p>​      3）逻辑错误：程序没有按照预期的逻辑顺序执行</p><p>​      4）异常：指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制</p><ol start="2"><li>分类</li></ol><p>​      1）Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。</p><p>​      2）Exception（异常）：是程序本身可以处理的异常。</p><ol start="3"><li>Exception（异常）分类</li></ol><p>​      1）运行时异常：一般是由程序逻辑错误引起的，当程序中可能出现这类异常，即使没有用try-catch语句捕获它或throws子句声明抛出它，也会编译通过。</p><p>​      2）非运行时异常 （编译异常）：从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。</p><ol start="4"><li>异常的处理</li></ol><p>​      1）抛出异常：throw，throws</p><p>​      2）捕获异常：try，catch，finally</p><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><ol><li>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</li><li>&amp;&amp;运算符是短路与运算。</li><li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。</li><li>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</li><li>很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)</li><li>二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</li></ol><h3 id="int和Integer有什么区别"><a href="#int和Integer有什么区别" class="headerlink" title="int和Integer有什么区别"></a>int和Integer有什么区别</h3><ol><li>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class）</li><li>int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换</li><li>Java 为每个原始类型提供了包装类型：</li></ol><p>​      1）原始类型: boolean，char，byte，short，int，long，float，double</p><p>​      2）包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><ol><li>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量</li><li>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身</li><li>所以对引用对象进行操作会同时改变原对象</li><li>一般认为,java内的传递都是值传递</li></ol><h3 id="Lamda表达式的优缺点"><a href="#Lamda表达式的优缺点" class="headerlink" title="Lamda表达式的优缺点"></a>Lamda表达式的优缺点</h3><ol><li>优点：</li></ol><p>​      1）简洁。</p><p>​      2）非常容易并行计算。</p><p>​      3）可能代表未来的编程趋势。</p><ol start="2"><li>缺点：</li></ol><p>​      1）若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）</p><p>​      2）不容易调试。</p><p>​      3）若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="类型" scheme="https://blog.yongkj.cn/tags/%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="区别" scheme="https://blog.yongkj.cn/tags/%E5%8C%BA%E5%88%AB/"/>
    
    <category term="异常" scheme="https://blog.yongkj.cn/tags/%E5%BC%82%E5%B8%B8/"/>
    
    <category term="传递" scheme="https://blog.yongkj.cn/tags/%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://blog.yongkj.cn/2021/02/03/java-object-oriented/"/>
    <id>https://blog.yongkj.cn/2021/02/03/java-object-oriented/</id>
    <published>2021-02-03T10:30:52.000Z</published>
    <updated>2021-02-10T08:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h3><ol><li>java面向对象的三大特征是什么?<br>封装、继承、多态。</li><li>封装<br>把属性和方法隐藏起来，只保留一些对外的接口和外部进行交互。</li><li>继承<br>子类继承父类的特征和行为，使得子类具有父类的非private属性和方法。</li><li>多态<br>多态就是同一个接口，使用不同的实现，而执行不同的操作。</li><li>抽象<br>将一类对象的共同特征总结出来构造类的过程，数据抽象指的是属性，行为抽象指的是方法。</li></ol><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><ol><li>抽象类</li></ol><p>​      1）抽象类是用来捕捉子类的通用特性的</p><p>​      2）它不能被实例化，只能被用作子类的超类</p><p>​      3）抽象类是被用来创建继承层级里子类的模板</p><ol start="2"><li>接口</li></ol><p>​      1）接口是抽象方法的集合</p><p>​      2）如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法</p><p>​      3）如果实现了这个接口，那么就必须确保使用这些方法</p><p>​      4）接口只是一种形式，接口自身不能做任何事情</p><ol start="3"><li>抽象类和接口的对比</li></ol><table><thead><tr><th align="left">参数</th><th align="left">抽象类</th><th>接口</th></tr></thead><tbody><tr><td align="left">默认的方法实现</td><td align="left">它可以有默认的方法实现</td><td>接口完全是抽象的。它根本不存在方法的实现</td></tr><tr><td align="left">实现</td><td align="left">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td align="left">构造器</td><td align="left">抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td align="left">与正常Java类的区别</td><td align="left">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td align="left">访问修饰符</td><td align="left">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td><td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td></tr><tr><td align="left">main方法</td><td align="left">抽象方法可以有main方法并且我们<strong>可以运行</strong>它</td><td>接口没有main方法，因此我们<strong>不能运行它</strong>。</td></tr><tr><td align="left">多继承</td><td align="left">抽象方法可以继承一个类和实现多个接口</td><td>接口只可以继承一个或多个其它接口</td></tr><tr><td align="left">速度</td><td align="left">它比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td></tr><tr><td align="left">添加新方法</td><td align="left">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td><td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td></tr></tbody></table><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol><li>概述</li></ol><p>​      1）把类定义在另一个类的内部，该类就被称为内部类</p><p>​      2）把类Inner定义在类Outer中，类Inner就被称为内部类</p><ol start="2"><li>访问规则</li></ol><p>​      1）可以直接访问外部类的成员，包括私有</p><p>​      2）外部类要想访问内部类成员，必须创建对象</p><ol start="3"><li>分类</li></ol><p>​      1）<strong>成员内部类</strong>：位于外部类成员位置的类，可以使用外部类中所有的成员变量和成员方法（包括private的）</p><p>​      2）<strong>局部内部类</strong>：定义在一个方法或者一个作用域里面的类，主要是作用域发生了变化，只能在自身所在方法和属性中被使用</p><p>​      3）<strong>静态内部类</strong>：用static修饰的内部类，不能使用外部类的非static成员变量和成员方法</p><p>​      4）<strong>匿名内部类</strong>：一个没有名字的类，是内部类的简化写法，其实是继承该类或者实现接口的子类匿名对象</p><h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><ol><li>方法重载</li></ol><p>​      1）同一个类中的多个方法具有相同的名字，这些方法具有不同的参数列表</p><p>​      2）参数类型和个数不一样，返回值类型可以相同也可以不相同</p><p>​      3）无法以返回型别作为重载函数的区分标准</p><p>​      4）重载Overloading是一个类中多态性的一种表现。</p><ol start="2"><li>方法重写</li></ol><p>​      1）子类定义的方法与父类中的方法具有相同的方法名字，相同的参数表和相同的返回类型</p><p>​      2）子类中不能重写父类中的final方法</p><p>​      3）子类中必须重写父类中的abstract方法</p><h3 id="hashCode-和equals-方法的联系"><a href="#hashCode-和equals-方法的联系" class="headerlink" title="hashCode()和equals()方法的联系"></a>hashCode()和equals()方法的联系</h3><ol><li><p>相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p></li><li><p>如果两个对象的hashCode相同，它们并不一定相同。</p></li></ol><h3 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final, finally, finalize的区别"></a>final, finally, finalize的区别</h3><ol><li>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li><li>finally是异常处理语句结构的一部分，表示总是执行。</li><li>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</li></ol><h3 id="Comparable和Comparator接口的作用以及区别"><a href="#Comparable和Comparator接口的作用以及区别" class="headerlink" title="Comparable和Comparator接口的作用以及区别"></a>Comparable和Comparator接口的作用以及区别</h3><ol><li>Comparable接口包含compareTo()方法。这个方法可以个给两个对象排序。</li><li>Comparator接口包含compare()和equals()方法。</li><li>compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。</li><li>equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。</li><li>只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</li></ol><h3 id="Java是否支持多继承"><a href="#Java是否支持多继承" class="headerlink" title="Java是否支持多继承"></a>Java是否支持多继承</h3><ol><li>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 </li><li>但是java中的接口支持多继承，，即一个子接口可以有多个父接口。</li><li>接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能。</li><li>当类实现接口时，类就扩展了相应的功能。</li></ol><h3 id="extends-和super-泛型限定符"><a href="#extends-和super-泛型限定符" class="headerlink" title="extends 和super 泛型限定符"></a>extends 和super 泛型限定符</h3><ol><li>泛型中上界和下界的定义</li></ol><p>​      1）上界&lt;? extend Fruit&gt;</p><p>​      2）下界&lt;? super Apple&gt;</p><ol start="2"><li>上界和下界的特点</li></ol><p>​      1）上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）</p><p>​      3）下界的list只能add，不能get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上界</span></span><br><span class="line">    List&lt;? extends Fruit&gt; flistTop = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    flistTop.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//add Fruit对象会报错</span></span><br><span class="line">    <span class="comment">//flist.add(new Fruit());</span></span><br><span class="line">    Fruit fruit1 = flistTop.get(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//下界</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> Apple&gt; flistBottem = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    <span class="comment">//get Apple对象会报错</span></span><br><span class="line">    <span class="comment">//Apple apple = flistBottem.get(0);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>上界&lt;? extend Fruit&gt; ，表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。</li><li>下界&lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object 。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。</li></ol><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><ol><li>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？</li><li>顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          List list = new ArrayList();</span></span><br><span class="line"><span class="comment">          list.add(&quot;qqyumidi&quot;);</span></span><br><span class="line"><span class="comment">          list.add(&quot;corn&quot;);</span></span><br><span class="line"><span class="comment">          list.add(100);</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;qqyumidi&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;corn&quot;</span>);</span><br><span class="line">        <span class="comment">//list.add(100);   // 1  提示编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String name = list.get(i); <span class="comment">// 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<String>，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="继承" scheme="https://blog.yongkj.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="实例" scheme="https://blog.yongkj.cn/tags/%E5%AE%9E%E4%BE%8B/"/>
    
    <category term="抽象" scheme="https://blog.yongkj.cn/tags/%E6%8A%BD%E8%B1%A1/"/>
    
    <category term="接口" scheme="https://blog.yongkj.cn/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://blog.yongkj.cn/2021/02/02/java-design-mode/"/>
    <id>https://blog.yongkj.cn/2021/02/02/java-design-mode/</id>
    <published>2021-02-02T07:24:52.000Z</published>
    <updated>2021-02-10T08:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><ol><li><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>所谓的单例设计指的是一个类只允许产生一个实例化对象。<br>最好理解的一种设计模式，分为懒汉式和饿汉式。</p></blockquote><ol><li>饿汉式</li></ol><p>​      1）构造方法私有化，外部无法产生新的实例化对象</p><p>​      2）只能通过static方法取得实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类的内部可以访问私有结构，所以可以在类的内部产生实例化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * private 声明构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回对象实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Singleton...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton singleton = Singleton.getInstance();</span><br><span class="line">singleton.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>懒汉式</li></ol><p>​      1）当第一次去使用Singleton对象的时候才会为其产生实例化对象的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供对外方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 还未实例化</span></span><br><span class="line"><span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton singleton = Singleton.getInstance();</span><br><span class="line">singleton.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p>工厂方法模式分为三种：</p><p>​      （1）普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p><p>​      （2）多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。</p><p>​      （3）静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p></blockquote><ol><li>普通工厂模式</li></ol><p>​      1）建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;This is mail sender...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;This is sms sender...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produce</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;mail&quot;</span>.equals(str)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sms&quot;</span>.equals(str)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入错误...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Sender sender = FactoryPattern.produce(<span class="string">&quot;mail&quot;</span>);</span><br><span class="line">sender.Send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多个工厂方法模式</li></ol><p>​      1）该模式是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is mail sender...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is sms sender...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">        Sender sender = factory.produceMail();</span><br><span class="line">        sender.Send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>静态工厂方法模式</li></ol><p>​      1）将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is mail sender...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is sms sender...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sender sender = SendFactory.produceMail();</span><br><span class="line">        sender.Send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？</p><p>那么这就用到了抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function">Sender <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is mail sender...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is sms sender...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendSmsFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider provider = <span class="keyword">new</span> SendMailFactory();</span><br><span class="line">        Sender sender = provider.produce();</span><br><span class="line">        sender.Send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote><p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一步：装CPU</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二步：装主板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildMainBoard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第三步：装硬盘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHD</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得组装好的电脑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">getComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装机人员装机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.buildCPU();</span><br><span class="line">        builder.buildMainBoard();</span><br><span class="line">        builder.buildHD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的装机人员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span>  <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;装CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMainBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;装主板&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.Add(<span class="string">&quot;装硬盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电脑组件集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; parts = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(String part)</span> </span>&#123;</span><br><span class="line">        parts.add(part);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;组件:&quot;</span> + parts.get(i) + <span class="string">&quot;装好了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑组装完毕...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        director.Construct(builder);</span><br><span class="line">        Computer computer = builder.getComputer();</span><br><span class="line">        computer.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3><blockquote><p>适配器模式是将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的的类的兼容性问题。主要分三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p></blockquote><ol><li>类的适配器模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is original method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与原类中的方法相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is the targetable method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Targetable targetable = <span class="keyword">new</span> Adapter();</span><br><span class="line">        targetable.method1();</span><br><span class="line">        targetable.method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对象的适配器模式</li></ol><p>​      1）基本思路和类的适配器模式相同，只是将Adapter 类作修改，这次不继承Source 类，而是持有Source 类的实例，以达到解决兼容性的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is original method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与原类中的方法相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        source.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is the targetable method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Source source = <span class="keyword">new</span> Source();</span><br><span class="line">        Targetable targetable = <span class="keyword">new</span> Wrapper(source);</span><br><span class="line">        targetable.method1();</span><br><span class="line">        targetable.method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接口的适配器模式</li></ol><p>​      1）有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义端口接口，提供通信服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Port</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程SSH端口为22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SSH</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网络端口为80</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NET</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tomcat容器端口为8080</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tomcat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MySQL数据库端口为3306</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MySQL</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义抽象类实现端口接口，但是什么事情都不做</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Port</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SSH</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NET</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tomcat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MySQL</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供聊天服务</span></span><br><span class="line"><span class="comment"> * 需要网络功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chat</span> <span class="keyword">extends</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NET</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网站服务器</span></span><br><span class="line"><span class="comment"> * 需要Tomcat容器，Mysql数据库，网络服务，远程服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SSH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connect success...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NET</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WWW...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tomcat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tomcat is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MySQL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MySQL is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Port chatPort = <span class="keyword">new</span> Chat();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Port serverPort = <span class="keyword">new</span> Server();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 聊天服务</span></span><br><span class="line">        chatPort.NET();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器</span></span><br><span class="line">        serverPort.SSH();</span><br><span class="line">        serverPort.NET();</span><br><span class="line">        serverPort.Tomcat();</span><br><span class="line">        serverPort.MySQL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><blockquote><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape: Rectangle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape: Circle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实现了 Shape 接口的抽象装饰类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  创建扩展自 ShapeDecorator 类的实体装饰类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">        setRedBorder(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RedShapeDecorator 来装饰 Shape 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        Shape redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">        Shape redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle with normal border&quot;</span>);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nCircle of red border&quot;</span>);</span><br><span class="line">        redCircle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nRectangle of red border&quot;</span>);</span><br><span class="line">        redRectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote><p>代理模式指给一个对象提供一个代理对象，并由代理对象控制对原对象的引用。代理可以分为静态代理和动态代理。</p><p>通过代理模式，可以利用代理对象为被代理对象添加额外的功能，以此来拓展被代理对象的功能。可以用于计算某个方法执行时间，在某个方法执行前后记录日志等操作。</p></blockquote><ol><li>静态代理</li></ol><p>​      1）静态代理需要我们写出代理类和被代理类，而且一个代理类和一个被代理类一一对应。代理类和被代理类需要实现同一个接口，通过聚合使得代理对象中有被代理对象的引用，以此实现代理对象控制被代理对象的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类和被代理类共同实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">implements</span> <span class="title">IService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理对象执行相关操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyService</span> <span class="keyword">implements</span> <span class="title">IService</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有被代理对象的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认代理Service类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = <span class="keyword">new</span> Service();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也可以代理实现相同接口的其他类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyService</span><span class="params">(IService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行service()方法&quot;</span>);</span><br><span class="line">        service.service();</span><br><span class="line">        System.out.println(<span class="string">&quot;service()方法执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IService service = <span class="keyword">new</span> Service();</span><br><span class="line">        <span class="comment">//传入被代理类的对象</span></span><br><span class="line">        ProxyService proxyService = <span class="keyword">new</span> ProxyService(service);</span><br><span class="line">        proxyService.service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态代理</li></ol><blockquote><p>JDK 1.3 之后，Java通过java.lang.reflect包中的三个类Proxy、InvocationHandler、Method来支持动态代理。动态代理常用于有若干个被代理的对象，且为每个被代理对象添加的功能是相同的（例如在每个方法运行前后记录日志）。</p><p>动态代理的代理类不需要我们编写，由Java自动产生代理类源代码并进行编译最后生成代理对象。</p><p>创建动态代理对象的步骤：</p><p>​      （1）指明一系列的接口来创建一个代理对象<br>​      （2） 创建一个调用处理器（InvocationHandler）对象<br>​      （3）将这个代理指定为某个其他对象的代理对象<br>​      （4）在调用处理器的invoke()方法中采取代理，一方面将调用传递给真实对象，另一方面执行各种需要的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类和被代理类共同实现的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">implements</span> <span class="title">IService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理对象执行相关操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object srcObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceInvocationHandler</span><span class="params">(Object srcObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.srcObject = srcObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxyObj, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行&quot;</span>+method.getName()+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">        <span class="comment">//执行原对象的相关操作，容易忘记</span></span><br><span class="line">        Object returnObj = method.invoke(srcObject,args);</span><br><span class="line">        System.out.println(method.getName()+<span class="string">&quot;方法执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IService service = <span class="keyword">new</span> Service();</span><br><span class="line">        Class&lt;? extends IService&gt; clazz = service.getClass();</span><br><span class="line"></span><br><span class="line">        IService proxyService = (IService) Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                                        clazz.getInterfaces(), <span class="keyword">new</span> ServiceInvocationHandler(service));</span><br><span class="line">        proxyService.service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><p>需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。</p><p>因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象算法的策略类，定义所有支持的算法的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体算法A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//算法A实现方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法A的实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体算法B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法B实现方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法B的实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体算法C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法C的实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上下文，维护一个对策略类对象的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.AlgorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码：实现不同的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context;</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">        context.contextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">        context.contextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyC());</span><br><span class="line">        context.contextInterface();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="工厂" scheme="https://blog.yongkj.cn/tags/%E5%B7%A5%E5%8E%82/"/>
    
    <category term="单例" scheme="https://blog.yongkj.cn/tags/%E5%8D%95%E4%BE%8B/"/>
    
    <category term="对象" scheme="https://blog.yongkj.cn/tags/%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="代理" scheme="https://blog.yongkj.cn/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>版本控制</title>
    <link href="https://blog.yongkj.cn/2021/02/01/java-version-control/"/>
    <id>https://blog.yongkj.cn/2021/02/01/java-version-control/</id>
    <published>2021-02-01T02:35:52.000Z</published>
    <updated>2021-02-10T08:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="为什么要使用版本管理工具"><a href="#为什么要使用版本管理工具" class="headerlink" title="为什么要使用版本管理工具"></a>为什么要使用版本管理工具</h3><ol><li><strong>备份文件</strong>：我们在日常开发中，代码备份必不可少。可以采用移动硬盘、网盘的形式来备份，但是以这种形式也有很多弊端。我们程序员一天的工作量都写在几个文件里面，如果说因为一些未知因素导致丢失了，这种情况损失还是挺大的。</li><li><strong>历史记录</strong>：即使我们上面所说，通过硬盘、网盘来备份，也只能保存当前最新的文件。而版本工具可以备份每一次所提交的代码，以及可以记录详细的修改信息，比如说某一行代码是谁在什么时候进行提交的。</li><li><strong>版本回退</strong>：当我们在开发过程中，也难免一些刚刚入职的同事不小心对代码所造成的伤害难以弥补的时候，这个时候我们也可以通版本管理工具，将当前的代码回退到之前提交的某个版本。</li><li><strong>多端共享</strong>：提供进行团队合作使用，总不能同事A写了一个方法，同事B需要用到这个方法，总不能让同事A拿着硬盘拷贝过去吧，所以采用管理工具只需将代码提交即可。 </li></ol><h3 id="版本控制（Version-Control-System）作用"><a href="#版本控制（Version-Control-System）作用" class="headerlink" title="版本控制（Version Control System）作用"></a>版本控制（Version Control System）作用</h3><ol><li>记录文件的所有历史变化</li><li>错误恢复到某个历史版本</li><li>多人协作开发编辑同一个文件</li></ol><h3 id="主流的版本控制产品"><a href="#主流的版本控制产品" class="headerlink" title="主流的版本控制产品"></a>主流的版本控制产品</h3><table><thead><tr><th>名称</th><th>模型</th><th>并发模式</th><th>历史模式</th><th>变更范围</th><th>网络协议</th><th>原子提交性</th></tr></thead><tbody><tr><td><strong>CVS</strong></td><td>Client-server</td><td>Merge</td><td>Changeset</td><td>File</td><td>Pserver,ssh</td><td>No</td></tr><tr><td><strong>SVN</strong></td><td>Client-server</td><td>3-way merge, recursive merge, octopus merge</td><td>Changeset and Snapshot</td><td>Tree</td><td>custom (svn), custom (svn) over ssh, HTTP and SSL (usingWebDAV)</td><td>Yes</td></tr><tr><td><strong>Git</strong></td><td>Distributed</td><td>Merge or lock</td><td>Snapshot</td><td>Tree</td><td>custom, custom over ssh, rsync, HTTP/HTTPS, email, bundles</td><td>Yes</td></tr></tbody></table><ol><li><strong>版本库模型（Repository model）：</strong>描述了多个源码版本库副本间的关系，有客户端/服务器和分布式两种模式。在客户端/服务器模式下，每一用户通过客户端访问位于服务器的主版本库，每一客户机只需保存它所关注的文件副本，对当前工作副本（working copy）的更改只有在提交到服务器之后，其它用户才能看到对应文件的修改。而在分布式模式下，这些源码版本库副本间是对等的实体，用户的机器出了保存他们的工作副本外，还拥有本地版本库的历史信息。</li><li><strong>并发模式（Concurrency model）：</strong>描述了当同时对同一工作副本/文件进行更改或编辑时，如何管理这种冲突以避免产生无意义的数据，有排它锁和合并模式。在排它锁模式下，只有发出请求并获得当前文件排它锁的用户才能对对该文件进行更改。而在合并模式下，用户可以随意编辑或更改文件，但可能随时会被通知存在冲突（两个或多个用户同时编辑同一文件），于是版本控制工具或用户需要合并更改以解决这种冲突。因此，几乎所有的分布式版本控制软件采用合并方式解决并发冲突。</li><li><strong>历史模式（History model）：</strong>描述了如何在版本库中存贮文件的更改信息，有快照和改变集两种模式。在快照模式下，版本库会分别存储更改发生前后的工作副本；而在改变集模式下，版本库除了保存更改发生前的工作副本外，只保存更改发生后的改变信息。</li><li><strong>变更范围（Scope of change）：</strong>描述了版本编号是针对单个文件还是整个目录树。</li><li><strong>网络协议（Network protocols）：</strong>描述了多个版本库间进行同步时采用的网络协议。</li><li><strong>原子提交性（Atomic commit）：</strong>描述了在提交更改时，能否保证所有更改要么全部提交或合并，要么不会发生任何改变。</li></ol><blockquote><p>简而言之，各有优缺点，git要配合hub，可以避免分布式损坏。svn有权限控制，避免全被clone走。git适合纯代码，svn适合综合性文档管理，结合起来就完美。显然最大的不同在于git是分布式的。</p></blockquote><h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><p><img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20180812141826593.png"></p><ol><li>优点：团队协作开发，代码集中化管理。</li><li>缺点：单点故障，必须联网工作，无法单机本地工作。</li></ol><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ol><li>git的概念</li></ol><p>​      1）git是世界上目前最先进的分布式版本控制系统,致力于团队、个人进行项目版本管理，完美的解决难以比较代码、难以合并代码、难以取消修改、难以在写当前代码的过程中保存未完成的修改去修改线上版本的bug等的痛点。</p><p>​      2）git是一个非常强大的工具，但作为一个git使用者来说，不用完全学习Git的知识点与命令，因为有的命令的使用频率非常的低甚至数年都不会用到。</p><ol start="2"><li>git的历史</li></ol><p>​      1）Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux的核心，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>​      2）事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>​      3）安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>​      4）Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><blockquote><p>git是linux的创始人linus，在付费版本控制工具BitMover收回对Linux社区免费使用权利的时候，一怒之下花费两个星期的时间写出来的。（不要逼牛笔的人）</p></blockquote><ol start="3"><li>组成结构</li></ol><p><img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20180812142233148.png"></p><p>​      1）<strong>工作区</strong>：用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>​      2）<strong>暂存区</strong>：保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</p><p>​      3）<strong>版本库</strong>：也叫本地版本库，之所以说git 快，大部分提交都是对本地仓库而言的，不依赖网络，最后一次会推送的到远程仓库。</p><p>​      4）<strong>远程仓库</strong>：可以看做是github，它是一个远程仓库，它提供web服务的 供大家方便下载、查看、提交、存储。文件的状态</p><ol start="4"><li>文件状态</li></ol><p><img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/2018081214362389.png"></p><p>​      1）新建文件状态为untracked</p><p>​      2）add命令执行后状态变为staged</p><p>​      3）已存在的文件状态为unmodified</p><p>​      4）修改文件内容，文件状态变为modified</p><p>​      5）commit提交，文件状态编程unmodifed。</p><h3 id="Git-常用基础命令"><a href="#Git-常用基础命令" class="headerlink" title="Git 常用基础命令"></a>Git 常用基础命令</h3><ol><li>配置用户信息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;dxj1718874198@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;YongKJ&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化本地 Git 仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ol start="3"><li>查看 Git 仓库状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git status -s #得到一种更为紧凑的格式输出</span><br></pre></td></tr></table></figure><p>​     <img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/20190621173015577.png"></p><p>​      1）新添加的未跟踪文件前面有 ?? 标记；</p><p>​      2）新添加到暂存区中的文件前面有 A 标记；</p><p>​      3）修改过的文件前面有 M 标记。 M 有两个可以出现的位置：</p><p>​      4）出现在右边的 M 表示该文件被修改了但是还没放入暂存区，</p><p>​      5）出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</p><p>​      6）加到暂存区之后，又修改了一次，修改之后，并没有添加到暂存区，前面有MM标记。</p><p>​      7）以此类推，如果加到暂存区之后，被修改了两次，修改之后，并没有添加到暂存区，前面有MMM标记。…</p><ol start="4"><li>文件添加到暂存区</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git add file1</span><br><span class="line"></span><br><span class="line">git add -A # 提交所有变化</span><br><span class="line"></span><br><span class="line">git add -u # 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</span><br><span class="line"></span><br><span class="line">git add . # 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</span><br><span class="line"></span><br><span class="line">git add * # 会忽略.gitignore把任何文件都加入</span><br></pre></td></tr></table></figure><ol start="5"><li>将本地暂存的修改提交到版本库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;add file1&quot; file1</span><br><span class="line"></span><br><span class="line">git commit -m &#x27;提交信息&#x27; # -m 参数是输入提交信息</span><br><span class="line"></span><br><span class="line">git commit -a -m &#x27;提交信息&#x27; # -a 参数可以把还没有执行add命令的修改一起提交</span><br></pre></td></tr></table></figure><ol start="6"><li>查看文件的修改内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff file1</span><br></pre></td></tr></table></figure><ol start="7"><li>查看git仓库提交日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line">git log --stat # 在git log 的基础上输出文件增删改的统计数据</span><br><span class="line"></span><br><span class="line">git log --oneline # 简化git log的默认的输出，仅仅输出commit hash 前7个字符串和commit</span><br></pre></td></tr></table></figure><ol start="8"><li>查看所有分支的所有操作记录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog # 包括已经被删除的 commit 记录和 reset 的操作</span><br></pre></td></tr></table></figure><ol start="9"><li>忽略文件</li></ol><p><img src="http://file.yongkj.cn/fileSystem/admin/My%20Learning%20Material/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/FastStoneEditor1.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">node_modules</span><br><span class="line">/dist</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">local</span> env files</span></span><br><span class="line">.env.local</span><br><span class="line">.env.*.local</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Log files</span></span><br><span class="line">npm-debug.log*</span><br><span class="line">yarn-debug.log*</span><br><span class="line">yarn-error.log*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Editor directories and files</span></span><br><span class="line">.idea</span><br><span class="line">.vscode</span><br><span class="line">*.suo</span><br><span class="line">*.ntvs*</span><br><span class="line">*.njsproj</span><br><span class="line">*.sln</span><br><span class="line">*.sw?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​      1）创建一个名为 .gitignore 的文件，列出要忽略的文件模式</p><p>​      2）星号（*）匹配零个或多个任意字符；</p><p>​      3）[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个c）；</p><p>​      4）问号（?）只匹配一个任意字符；</p><p>​      5）如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9]表示匹配所有 0 到 9 的数字）。</p><p>​      6）使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或a/b/c/z等</p><ol start="10"><li>工作区和暂存区</li></ol><p>​      1）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>​      2）Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p>​      3）第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>​      4）第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><ol start="11"><li>丢弃工作区的修改</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file1</span><br></pre></td></tr></table></figure><ol start="12"><li>撤销暂存区的修改（unstage），重新放回工作区</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure><ol start="13"><li>版本回退</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">git reset --hard ID号码</span><br></pre></td></tr></table></figure><ol start="14"><li>误删，还原</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout file1</span><br></pre></td></tr></table></figure><ol start="15"><li>删除版本库中文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm file1</span><br><span class="line"></span><br><span class="line">git commit -m &quot;del file1&quot;</span><br></pre></td></tr></table></figure><ol start="16"><li>创建分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><ol start="17"><li>查看分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看所有分支</span><br><span class="line"></span><br><span class="line">git branch -v # 查看所有分支详情</span><br></pre></td></tr></table></figure><ol start="18"><li>切换分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt; # 切换到指定分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;branch_name&gt; # 创建并切换到指定分支</span><br></pre></td></tr></table></figure><ol start="19"><li>删除分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch_name&gt; # 删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录)</span><br><span class="line"></span><br><span class="line">git branch -D &lt;branch_name&gt; # 强制删除一个分支，该分支有没有合并到当前分支的提交记录</span><br></pre></td></tr></table></figure><blockquote><p>注意：删除分支前都需要先切换到其他分支才能进行删除操作</p></blockquote><ol start="20"><li>分支恢复</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog # 查找该分支指向的commitId</span><br><span class="line"></span><br><span class="line">git branch &lt;branch_name&gt; &lt;hash_val&gt; # 根据指定commit创建新分支</span><br></pre></td></tr></table></figure><ol start="21"><li>重命名分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;branch_name&gt; newname</span><br></pre></td></tr></table></figure><ol start="22"><li>分支合并</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt; # 将指定分支合并到当前分支，如果两个分支没有产生分叉情况，那么会进行快速合并，即fast-forward方式</span><br></pre></td></tr></table></figure><ol start="23"><li>分支合并细节</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;msg&quot; &lt;branch_name&gt; # 合并分支时禁用Fast forward模式</span><br></pre></td></tr></table></figure><ol start="24"><li>冲突解决</li></ol><p>​      1）当对分叉分支进行合并时，如果两个分支都对同一文件进行了修改，那么合并时就有可能会产生冲突情况。</p><p>​      2）如果两个分支对同一文件的修改是有规律的，比如对不同地方的修改，那么git工具可以实现自动合并</p><p>​      3）如果无法自动合并，则需要对冲突文件进行手动修改，修改完成后使用git add表示冲突已经解决，然后使用git commit进行提交</p><ol start="25"><li>分支暂存</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash # 将工作暂存</span><br><span class="line"></span><br><span class="line">git stash list # 所有的暂存状态</span><br></pre></td></tr></table></figure><ol start="26"><li>从暂存区之中进行恢复，有两种处理方式：</li></ol><p>​      1）先恢复，而后再删除暂存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line">git stash drop</span><br></pre></td></tr></table></figure><p>​      2）恢复的同时也将stash内容删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><ol start="27"><li>本地仓库推送到远程仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程仓库地址 # 将本地仓库和远程仓库进行关联</span><br><span class="line"></span><br><span class="line">git push -u origin master # 把本地仓库的项目推送到远程仓， 第一次推送</span><br><span class="line"></span><br><span class="line">git push origin master # 第一次推送后，直接使用该命令即可推送修改</span><br><span class="line"></span><br><span class="line">git push origin 本地分支:远端希望创建的分支</span><br><span class="line"></span><br><span class="line">git push origin master:my_remote_new_branch # 远端即可创建新的分支my_remote_new_branch,提交本地修改</span><br><span class="line"></span><br><span class="line">git remote -v # 查看远程仓库地址命令</span><br><span class="line"></span><br><span class="line">git remote set-url origin url # 直接修改远程仓库地址</span><br><span class="line"></span><br><span class="line">git remote rm origin # 删除本地远程仓库地址</span><br><span class="line"></span><br><span class="line">git remote add origin url # 然后添加新的仓库地址</span><br><span class="line"></span><br><span class="line">git config --global http.proxy &#x27;http://127.0.0.1:58591&#x27;</span><br><span class="line"></span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:51837&#x27;</span><br><span class="line"></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><blockquote><p>注意有坑： 新建远程仓库的时候如果你勾选了<code>Initialize this repository with a README</code>（就是创建仓库的时候自动给你创建一个README文件），那么到了第7步你将本地仓库内容推送到远程仓库的时候就会报一个<code>failed to push some refs to 远程仓库地址</code>的错。</p><p>原因： 由于你新创建的那个仓库里面的<code>README.md</code>文件不在本地仓库目录中，这时我们可以通过<code>git pull --rebase origin master</code>命令先将内容合并,此时再push就能成功了。</p></blockquote><ol start="28"><li>克隆远程仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 远程仓库地址 # 从远程服务器克隆一个一模一样的版本库到本地，复制的是整个版本库</span><br></pre></td></tr></table></figure><ol start="29"><li>获取最新版本远程仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line"></span><br><span class="line">git pull # 从远程获取最新版本并merge（合并）到本地，git pull = git fetch + git merge，git fetch更安全一些</span><br></pre></td></tr></table></figure><ol start="30"><li>清理本地仓库（以Hexo静态博客为例）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于现在的.git文件夹里累积了太多辣鸡数据，甚至已经超过博客本身的大小了，于是打算从头开始重新部署一下博客的所有静态资源。</span></span><br><span class="line"></span><br><span class="line">git checkout --orphan new_branch # 新建空白分枝</span><br><span class="line"></span><br><span class="line">npm run build # 生成静态文件</span><br><span class="line"></span><br><span class="line">git add . # 添加文件到暂存区</span><br><span class="line"></span><br><span class="line">git commit -m &#x27;提交信息&#x27; # 提交分枝更改</span><br><span class="line"></span><br><span class="line">git branch -D master # 删除旧主分枝</span><br><span class="line"></span><br><span class="line">git branch -m master # 改名为主分枝</span><br><span class="line"></span><br><span class="line">git push -f origin master # 强制推至上游</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 干净的博客出现了！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="管理" scheme="https://blog.yongkj.cn/tags/%E7%AE%A1%E7%90%86/"/>
    
    <category term="命令" scheme="https://blog.yongkj.cn/tags/%E5%91%BD%E4%BB%A4/"/>
    
    <category term="暂存" scheme="https://blog.yongkj.cn/tags/%E6%9A%82%E5%AD%98/"/>
    
    <category term="仓库" scheme="https://blog.yongkj.cn/tags/%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://blog.yongkj.cn/2021/01/31/java-database/"/>
    <id>https://blog.yongkj.cn/2021/01/31/java-database/</id>
    <published>2021-01-31T12:55:52.000Z</published>
    <updated>2021-02-10T08:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><ol><li>定义</li></ol><p>​      1）数据库事务是构成单一逻辑工作单元的操作集合，包含一个或多个数据库操作，这些操作构成一个逻辑上的整体。</p><p>​      2）一个典型的数据库事务如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANSACTION  &#x2F;&#x2F;事务开始</span><br><span class="line">SQL1</span><br><span class="line">SQL2</span><br><span class="line">COMMIT&#x2F;ROLLBACK   &#x2F;&#x2F;事务提交或回滚</span><br></pre></td></tr></table></figure><ol start="2"><li>事务的ACID特性</li></ol><p>​      1）**原子性(Atomicity)**：事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功，要么全部失败。</p><p>​      2）**一致性(Consistency)**：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。</p><p>​      3）**隔离性(Isolation)**：并发执行的事务不会相互影响，其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账，最后账户的结果应该和他们按先后次序转账的结果一样。</p><p>​      4）**持久性(Durability)**：事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p><blockquote><p>一致性状态：</p><ol><li><p>系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) </p></li><li><p>系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。</p></li></ol></blockquote><h3 id="数据库的脏读、幻读、不可重复读"><a href="#数据库的脏读、幻读、不可重复读" class="headerlink" title="数据库的脏读、幻读、不可重复读"></a>数据库的脏读、幻读、不可重复读</h3><ol><li>脏读：</li></ol><p>​      1）指一个事务A正在访问数据，并且对该数据进行了修改，但是这种修改还没有提交到数据库中（也可能因为某些原因Rollback了）。这时候另外一个事务B也访问这个数据，然后使用了这个被A修改的数据，那么这个数据就是脏的，并不是数据库中真实的数据。这就被称作脏读。</p><p>​      2）解决办法：把数据库事务隔离级别调整到READ_COMMITTED</p><p>​      3）即让用户在更新时锁定数据库，阻止其他用户读取，直到更新全部完成才让你读取。</p><ol start="2"><li>幻读：</li></ol><p>​      1）指一个事务A对一个表中的数据进行了修改，而且该修改涉及到表中所有的数据行；同时另一个事务B也在修改表中的数据，该修改是向表中插入一行新数据。那么经过这一番操作之后，操作事务A的用户就会发现表中还有没修改的数据行，就像发生了幻觉一样。这就被称作幻读。</p><p>​      2）解决办法：把数据库事务隔离级别调整到SERIALIZABLE_READ</p><ol start="3"><li>不可重复读：</li></ol><p>​      1）指在一个事务A内，多次读同一个数据，但是事务A没有结束时，另外一个事务B也访问该同一数据。那么在事务A的两次读数据之间，由于事务B的修改导致事务A两次读到的数据可能是不一样的。这就发生了在一个事务内两次读到的数据不一样，这就被称作不可重复读。</p><p>​      2）解决办法：把数据库事务隔离级别调整到REPEATABLE_READ</p><blockquote><p>注：</p><p>级别高低：脏读 &lt; 不可重复读 &lt; 幻读</p><p>所以设置了最高级别的SERIALIZABLE_READ就不需要设置其他的了，即解决了幻读问题那么脏度和不可重复读自然就都解决了。</p></blockquote><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ol><li>为什么需要索引？</li></ol><p>​      1）索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据，解决效率低问题</p><ol start="2"><li>优点</li></ol><p>​      1）可以通过建立唯一索引或者主键索引，保证数据库表中每一行数据的唯一性</p><p>​      2）建立索引可以大大提高检索的数据，以及减少表的检索行数</p><p>​      3）在表连接的连接条件，可以加速表与表直接的相连</p><p>​      4）在分组和排序字句进行数据检索，可以减少查询时间中分组和排序时所消耗的时间(数据库的记录会重新排序)</p><p>​      5）建立索引，在查询中使用索引 可以提高性能</p><ol start="3"><li>索引采取什么样的结构</li></ol><p>​      1）hash(哈希)</p><p>​      2）二叉树</p><p>​      3）红黑树</p><p>​      4）B+树</p><h3 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h3><ol><li>多表联合查询</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> py_user u, py_paths p <span class="keyword">where</span> u.userUUID = p.userUUID;</span><br></pre></td></tr></table></figure><ol start="2"><li>内连接查询（与多表联合查询效果一样）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> py_user u <span class="keyword">INNER</span> <span class="keyword">JOIN</span> py_paths p <span class="keyword">ON</span> u.userUUID = p.userUUID;</span><br></pre></td></tr></table></figure><ol start="3"><li>左外连接查询 (左边表中的数据优先全部显示)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> py_user u <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> py_paths p <span class="keyword">ON</span> u.userUUID = p.userUUID;</span><br></pre></td></tr></table></figure><ol start="4"><li>右外连接查询 (右边表中的数据优先全部显示)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> py_user u <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> py_paths p <span class="keyword">ON</span> u.userUUID = p.userUUID;</span><br></pre></td></tr></table></figure><ol start="5"><li>全连接查询(显示左右表中全部数据,使用 UNION 可以间接实现 full JOIN 功能)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> py_user u <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> py_paths p <span class="keyword">ON</span> u.userUUID = p.userUUID;</span><br><span class="line">UNION</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> py_user u <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> py_paths p <span class="keyword">ON</span> u.userUUID = p.userUUID;</span><br></pre></td></tr></table></figure><ol start="6"><li>子查询(嵌套查询)： 查多次，多个select</li></ol><p>​      1）第一次的查询结果可以作为第二次的查询的条件或者表名使用.</p><p>​      2）子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字. 还可以包含比较运算符：= 、 !=、&gt; 、&lt; 等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> person) <span class="keyword">as</span> 表名;</span><br></pre></td></tr></table></figure><ol start="7"><li>ORDER BY 排序，ASC默认升序，降序后面接”DESC”即可</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name1, column_name2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><ol start="8"><li>GROUP BY 分组，count(*) 包括所有列，返回表中的记录数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.userName, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> py_user u, py_paths p <span class="keyword">WHERE</span> u.userUUID = p.userUUID <span class="keyword">GROUP</span> <span class="keyword">BY</span> regEmail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> u.userName, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> py_user u <span class="keyword">INNER</span> <span class="keyword">JOIN</span> py_paths p <span class="keyword">ON</span> u.userUUID = p.userUUID <span class="keyword">GROUP</span> <span class="keyword">BY</span> regEmail;</span><br></pre></td></tr></table></figure><ol start="9"><li>AVG() 求平均工资</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="keyword">FROM</span> person;</span><br></pre></td></tr></table></figure><ol start="10"><li>MAX() 求最大工资</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="keyword">FROM</span> person;</span><br></pre></td></tr></table></figure><ol start="11"><li>MIN() 求最小工资</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary) <span class="keyword">FROM</span> person;</span><br></pre></td></tr></table></figure><ol start="12"><li>HAVING 和 WHERE 的区别</li></ol><p>​      1）作用的对象不同。WHERE 子句作用于表和视图，HAVING 子句作用于组。</p><p>​      2）WHERE 在分组和聚集计算之前选取输入行（因此，它控制哪些行进入聚集计算）， 而 HAVING 在分组和聚集之后选取分组的行。</p><p>​      3）WHERE 子句不能包含聚集函数，HAVING 子句总是包含聚集函数。</p><p>​      4）HAVING 一般跟在 GROUP BY 之后，执行记录组选择的一部分来工作的。WHERE 则是执行所有数据来工作的</p><p>​     5）HAVING 可以用聚合函数，如 HAVING SUM(salary) &gt; 1000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city <span class="keyword">FROM</span> weather <span class="keyword">WHERE</span> temp_lo = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(temp_lo) <span class="keyword">FROM</span> weather);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="事务" scheme="https://blog.yongkj.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="数据" scheme="https://blog.yongkj.cn/tags/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="索引" scheme="https://blog.yongkj.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="查询" scheme="https://blog.yongkj.cn/tags/%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="https://blog.yongkj.cn/2021/01/30/java-thread/"/>
    <id>https://blog.yongkj.cn/2021/01/30/java-thread/</id>
    <published>2021-01-30T12:16:52.000Z</published>
    <updated>2021-02-10T08:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><ol><li>进程是操作系统资源分配的基本单位</li><li>线程是cpu调度和分配的基本单位</li><li>一个进程可以有多个线程</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高</li></ol><h3 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h3><ol><li><strong>新建状态（New）</strong>：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</li><li><strong>就绪状态（Runnable）</strong>：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li><li><strong>运行状态（Running）</strong>：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li><li><strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</li></ol><ul><li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li></ul><ol start="5"><li><strong>死亡状态（Dead）</strong>：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ol><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ol><li><strong>继承Thread类</strong></li></ol><p>​      1）创建一个线程子类继承Thread类</p><p>​      2）重写run() 方法，把需要线程执行的程序放入run方法，线程启动后方法里的程序就会运行</p><p>​      3）创建该类的实例，并调用对象的start()方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;需要运行的程序。。。。。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>实现Runnable接口</strong></li></ol><p>​      1）定义一个线程类实现Runnable接口，并重写该接口的run()方法，方法中依然是包含指定执行的程序</p><p>​      2）创建一个Runnable实现类实例，将其作为target参数传入，并创建Thread类实例</p><p>​      3）调用Thread类实例的start()方法启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Runnable接口......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableDemo demo = <span class="keyword">new</span> RunnableDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(demo);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用Callable和Future创建线程</strong> </li></ol><p>​      1）创建Callable接口的实现类，实现call() 方法</p><p>​      2）创建Callable实现类实例，通过FutureTask类来包装Callable对象，该对象封装了Callable对象的call()方法的返回值</p><p>​      3）将创建的FutureTask对象作为target参数传入，创建Thread线程实例并启动新线程</p><p>​      4）调用FutureTask对象的get方法获取返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUtil</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadUtil</span><span class="params">(StudentService studentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentService = studentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Student&gt; students = studentService.allStudentsList();</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> StudentService studentService = <span class="keyword">new</span> StudentService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取FutureTask对象</span></span><br><span class="line">        ThreadUtil threadUtil = <span class="keyword">new</span> ThreadUtil(studentService);</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(threadUtil);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.开启线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 3.使用Futura#get()方法获取线程的返回值</span></span><br><span class="line">            List&lt;Student&gt; studentList = (List&lt;Student&gt;) futureTask.get();</span><br><span class="line">            studentList.forEach(student -&gt; System.out.println(student));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>wait()：使一个线程处于等待状态，并且释放所持有的对象的lock。</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。</li><li>notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</li><li>notifyAll()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li><li>yield()：暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。</li><li>join()：父线程等待子线程执行完成后再执行，换句话说就是将异步执行的线程合并为同步的线程。</li><li>synchronized：Java中的关键字，是一种同步锁。用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</li><li>volatile：保证了变量的可见性（visibility）。被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象</li><li>lock：加锁限定线程间的互斥，保持线程同步实现线程安全</li></ol><blockquote><p><a href="https://www.cnblogs.com/paddix/p/5381958.html">Java 并发编程：线程间的协作(wait/notify/sleep/yield/join)</a></p></blockquote><h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ol><li><p>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的，需要从主存中读取,synchronized则是锁定当前变量，只有当前线程可以访问该变量,其他线程被阻塞住</p></li><li><p>volatile仅能使用在变量级别，synchronized则可以使用在变量、方法</p></li><li><p>volatile仅能实现变量的修改可见性，而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞，而synchronized可能会造成线程的阻塞</p></li><li><p>当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower&lt;=upper的限制。</p></li><li><p>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。</p></li></ol><h3 id="synchronized与lock的异同"><a href="#synchronized与lock的异同" class="headerlink" title="synchronized与lock的异同"></a>synchronized与lock的异同</h3><ol><li>Lock能完成synchronized所实现的所有功能</li><li>Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放，否则会引起死锁。</li><li>synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。</li><li>synchronized是托管给JVM执行的，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。</li><li>lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。</li><li>在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。</li></ol><h3 id="sleep-和-yield-的区别"><a href="#sleep-和-yield-的区别" class="headerlink" title="sleep() 和 yield() 的区别"></a>sleep() 和 yield() 的区别</h3><ol><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li><li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li></ol><h3 id="sleep-和-wait-有的区别"><a href="#sleep-和-wait-有的区别" class="headerlink" title="sleep() 和 wait() 有的区别"></a>sleep() 和 wait() 有的区别</h3><ol><li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol><li>定义</li></ol><p>​      1）线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p><ol start="2"><li>优点</li></ol><p>​      1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>​      2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。</p><p>​      3）提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p><ol start="3"><li>分类</li></ol><p>​      1）<strong>newSingleThreadExecutor</strong>：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>​      2）<strong>newFixedThreadPool</strong>：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>​      3）<strong>newScheduledThreadPool</strong>：创建一个可定期或者延时执行任务的定长线程池，支持定时及周期性任务执行。 </p><p>​      4）<strong>newCachedThreadPool</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </p><ol start="4"><li>状态</li></ol><p>​      1）<strong>Running</strong>：能接受新任务以及处理已添加的任务</p><p>​      2）<strong>Shutdown</strong>：不接受新任务，可以处理已添加的任务</p><p>​      3）<strong>Stop</strong>：不接受新任务，不处理已添加的任务，并且中断正在处理的任务</p><p>​      4）<strong>Tidying</strong>：所有任务已终止，ctl记录为”任务数量”为0，ctl负责记录线程池的运行状态与活动线程数量</p><p>​      5）<strong>Terminated</strong>：线程池彻底终止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="创建" scheme="https://blog.yongkj.cn/tags/%E5%88%9B%E5%BB%BA/"/>
    
    <category term="分配" scheme="https://blog.yongkj.cn/tags/%E5%88%86%E9%85%8D/"/>
    
    <category term="状态" scheme="https://blog.yongkj.cn/tags/%E7%8A%B6%E6%80%81/"/>
    
    <category term="阻塞" scheme="https://blog.yongkj.cn/tags/%E9%98%BB%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://blog.yongkj.cn/2021/01/29/java-assemble/"/>
    <id>https://blog.yongkj.cn/2021/01/29/java-assemble/</id>
    <published>2021-01-29T12:38:52.000Z</published>
    <updated>2021-02-10T08:01:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="集合的分类"><a href="#集合的分类" class="headerlink" title="集合的分类"></a>集合的分类</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection 接口的接口 对象的集合（单列集合）</span><br><span class="line">├——-List 接口：元素按进入先后有序保存，可重复</span><br><span class="line">│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全</span><br><span class="line">│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全</span><br><span class="line">│—————-└ Vector 接口实现类 数组， 同步， 线程安全</span><br><span class="line">│ ———————-└ Stack 是Vector类的实现类</span><br><span class="line">└——-Set 接口： 仅接收一次，不可重复，并做内部排序</span><br><span class="line">├—————-└HashSet 使用hash表（数组）存储元素</span><br><span class="line">│————————└ LinkedHashSet 链表维护元素的插入次序</span><br><span class="line">└ —————-TreeSet 底层实现为二叉树，元素排好序</span><br><span class="line"></span><br><span class="line">Map 接口 键值对的集合 （双列集合）</span><br><span class="line">├———Hashtable 接口实现类， 同步， 线程安全</span><br><span class="line">├———HashMap 接口实现类 ，没有同步， 线程不安全</span><br><span class="line">│—————–├ LinkedHashMap 双向链表和哈希表实现</span><br><span class="line">│—————–└ WeakHashMap</span><br><span class="line">├ ——–TreeMap 红黑树对所有的key进行排序</span><br><span class="line">└———IdentifyHashMap</span><br></pre></td></tr></table></figure><h3 id="List、Map、Set-接口存取元素特点"><a href="#List、Map、Set-接口存取元素特点" class="headerlink" title="List、Map、Set  接口存取元素特点"></a>List、Map、Set  接口存取元素特点</h3><ol><li><p>List 以特定索引来存取元素，可以有重复元素。</p></li><li><p>Set 不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</p></li><li><p>Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</p></li></ol><h3 id="Collection-和-Collections-的区别"><a href="#Collection-和-Collections-的区别" class="headerlink" title="Collection 和 Collections 的区别"></a>Collection 和 Collections 的区别</h3><ol><li>Collection是集合类的上级接口，继承与它的接口主要有Set 和 List.</li><li>Collections是针对集合类的一个帮助类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ol><h3 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h3><ol><li>ArrayList 和 LinkedList 都实现了List接口</li><li>ArrayList是实现了基于动态数组的数据结构，LinkedList实现了基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li><li>ArrayList和LinkedListed都是非线程安全的，但可通过工具类Collections中的synchronizedList方法转换成线程安全容器</li></ol><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol><li>继承的父类</li></ol><ul><li>都实现了Map、Cloneable（可复制）、Serializable（可序列化）接口。</li><li>HashMap: 继承自AbstractMap类。</li><li>HashTable: 继承自Dictionary类。</li></ul><ol start="2"><li><p>HashMap 是线程不安全的，效率高；HashTable 线程安全，效率低。</p></li><li><p>HashMap允许键和值是null，而Hashtable不允许键或者值是null</p></li></ol><h3 id="Iterator-和-ListIterator-的区别"><a href="#Iterator-和-ListIterator-的区别" class="headerlink" title="Iterator 和 ListIterator 的区别"></a>Iterator 和 ListIterator 的区别</h3><ol><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ol><h3 id="Java集合类里面最基本的接口"><a href="#Java集合类里面最基本的接口" class="headerlink" title="Java集合类里面最基本的接口"></a>Java集合类里面最基本的接口</h3><ul><li>Collection：代表一组对象，每一个对象都是它的子元素。</li><li>Set：不包含重复元素的Collection。</li><li>List：有顺序的collection，并且可以包含重复元素。</li><li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol><li>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment</li><li>HashEntry 用来封装映射表的键 / 值对</li><li>Segment 用来充当锁的角色</li><li>Concurrenthashmap线程安全的</li></ol><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol><li>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。</li><li>该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。</li><li>红黑树性质：</li></ol><ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点永远是黑色的。</li><li>所有的叶节点都是空节点（即 null），并且是黑色的。</li><li>每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</li><li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol><li>如果HashMap的key是自定义的类，就必须重写hashcode()和equals()。</li><li>HashMap在JDK1.8的版本中引入了红黑树结构做优化</li><li>当链表元素个数大于等于8时，链表转换成树结构，小于等于6时，树结构还原成链表。</li><li>如果一个HashMap不停的插入、删除元素，并且链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Java学习" scheme="https://blog.yongkj.cn/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数组" scheme="https://blog.yongkj.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="链表" scheme="https://blog.yongkj.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="元素" scheme="https://blog.yongkj.cn/tags/%E5%85%83%E7%B4%A0/"/>
    
    <category term="同步" scheme="https://blog.yongkj.cn/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Education</title>
    <link href="https://blog.yongkj.cn/2020/11/23/education/"/>
    <id>https://blog.yongkj.cn/2020/11/23/education/</id>
    <published>2020-11-23T07:34:03.000Z</published>
    <updated>2020-11-23T07:55:30.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/23/education/Home-education.jpg" class="" title="Home-education.jpg"><p>&emsp;&emsp;Chinese families attach great importance to their children’s education. Many parents believe that they should work hard to ensure that their children are well educated. Not noly are they perfectly willing to invest in their children’s education, but they also spend a lot of time urging their children to learn. Most parents hope that their children will attend a prestigious university. Due to the reform and opening up, more and more parents can send their children abroad to study or participate in international exchange programs to broaden their horizons. Through these efforts, they expect their children to grow healthily and contribute to the development and prosperity of the country.</p><p>&emsp;&emsp;中国家庭十分重视孩子的教育。许多父母认为应该努力工作，确保孩子受到良好教育。他们不仅非常情愿为孩子的教育投资，而且花很多时间督促他们学习。多数家长希望孩子能上名牌大学。由于改革开放，越来越多的家长能送孩子到国外学习或参与国际交流项目，以拓宽其视野。通过这些努力，他们期望孩子健康成长，为国家的发展和繁荣作出贡献。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="education" scheme="https://blog.yongkj.cn/tags/education/"/>
    
    <category term="invest" scheme="https://blog.yongkj.cn/tags/invest/"/>
    
    <category term="participate" scheme="https://blog.yongkj.cn/tags/participate/"/>
    
    <category term="contribute" scheme="https://blog.yongkj.cn/tags/contribute/"/>
    
  </entry>
  
  <entry>
    <title>A Letter to a Foreign Friend Who Wants to Teach English in China</title>
    <link href="https://blog.yongkj.cn/2020/11/23/teach-English-in-China/"/>
    <id>https://blog.yongkj.cn/2020/11/23/teach-English-in-China/</id>
    <published>2020-11-23T06:46:52.000Z</published>
    <updated>2020-11-23T07:29:01.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/23/teach-English-in-China/caniteachenglishabroadifimanonnativespeaker_1780282505.jpg" class="" title="caniteachenglishabroadifimanonnativespeaker_1780282505.jpg"><p><strong>Dear Tom,</strong><br>&emsp;&emsp;<strong>On hearing that you are planning to teach English in China and inquire which city to work in, I’d like to recommend</strong> our capital city Beijing to you, which is an international metropolis.<br>&emsp;&emsp;<strong>The reasons why I recommend Beijing can be listed as follows. First of all,</strong> there are a lot of English-speaking foreigners in Beijing, which could help you adapt to life here very quickly. <strong>Furthermore,</strong> as the capital of several dynasties, Beijing has a profound cultural background, so you can better experience the extensive and profound traditional Chinese culture in Beijing. <strong>Most importantly,</strong> parents in Beijing attach great importance to their children’s English learning and many people who work in multinational companies alse need to learn English.<br>&emsp;&emsp;<strong>I truly hope that</strong> you can come to Beijing to start your teaching life and I’m looking forward to your arrival. <strong>If you have any question about</strong> the city, <strong>please feel free to contact me for further information.</strong><br><strong><p align="right">Yours sincerely,<br>Li Ming</p></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="teach" scheme="https://blog.yongkj.cn/tags/teach/"/>
    
    <category term="foreign" scheme="https://blog.yongkj.cn/tags/foreign/"/>
    
    <category term="recommend" scheme="https://blog.yongkj.cn/tags/recommend/"/>
    
    <category term="information" scheme="https://blog.yongkj.cn/tags/information/"/>
    
  </entry>
  
  <entry>
    <title>Subway</title>
    <link href="https://blog.yongkj.cn/2020/11/23/subway/"/>
    <id>https://blog.yongkj.cn/2020/11/23/subway/</id>
    <published>2020-11-23T01:10:51.000Z</published>
    <updated>2020-11-23T01:30:11.452Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/23/subway/NYC+subway+station.jpeg" class="" title="NYC+subway+station.jpeg"><p>&emsp;&emsp;In recent years, more and more cities in China have begun to build subways. The development of subways can help reduce traffic congestion and air pollution in cities. The subway has the advantages of safety, speed and comfort. More and more people choose the subway as the main means of transportation to work or school every day. Nowadays, it is becoming more and more convenient to take the subway in China. In some cities, passengers can use a card or a mobile phone to take the subway. Many local elderly citizens can also take the subway for free.</p><p>&emsp;&emsp;近年来，中国有越来越多的城市开始建设地铁。发展地铁有助于减少城市的交通拥挤和空气污染。地铁具有安全、快捷和舒适的优点。越来越多的人选择地铁作为每天上班或上学的主要交通工具。如今，在中国乘坐地铁正变得越来越方便。在有些城市里，乘客只需用卡或手机就可以乘坐地铁。许多当地老年市民还可以免费乘坐地铁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="city" scheme="https://blog.yongkj.cn/tags/city/"/>
    
    <category term="comfort" scheme="https://blog.yongkj.cn/tags/comfort/"/>
    
    <category term="convenient" scheme="https://blog.yongkj.cn/tags/convenient/"/>
    
    <category term="free" scheme="https://blog.yongkj.cn/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>The Important of Speaking Ability and How to Develop It</title>
    <link href="https://blog.yongkj.cn/2020/11/23/improve-speaking-skills/"/>
    <id>https://blog.yongkj.cn/2020/11/23/improve-speaking-skills/</id>
    <published>2020-11-23T00:18:30.000Z</published>
    <updated>2020-11-23T00:52:11.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/23/improve-speaking-skills/Young-Swiss-prefer-English.jpg" class="" title="Young-Swiss-prefer-English.jpg"><p>&emsp;&emsp;<strong>As we all know,</strong> proficiency in speaking is necessary for us to become well-rounded communicators. <strong>However,</strong> the capacity to put words together in a meaningful way to reflect thoughts, opinions, and feelings is not something we’re born with but needs some techniques and practice.<br>&emsp;&emsp;<strong>Firstly,</strong> build confidence and concentrate on getting our message across, which help us gain the attention of the audience in return. <strong>Secondly,</strong> experiment with the things we know well instead of challenging ourselves with difficult words since fluency appears more important during oral communication. <strong>Lastly,</strong> create some opportunities to practice like narrating our daily life to ourselves or maintaining a regular chat with friends.<br>&emsp;&emsp;<strong>To sum up,</strong> only by being confident enough and using efficient methods can we enhance our speaking ability. Follow the steps to improve our speaking skills in order to achieve a higher standard in communication.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="speaking" scheme="https://blog.yongkj.cn/tags/speaking/"/>
    
    <category term="apility" scheme="https://blog.yongkj.cn/tags/apility/"/>
    
    <category term="communication" scheme="https://blog.yongkj.cn/tags/communication/"/>
    
    <category term="enhance" scheme="https://blog.yongkj.cn/tags/enhance/"/>
    
  </entry>
  
  <entry>
    <title>Buses</title>
    <link href="https://blog.yongkj.cn/2020/11/06/travel-by-bus/"/>
    <id>https://blog.yongkj.cn/2020/11/06/travel-by-bus/</id>
    <published>2020-11-06T01:26:49.000Z</published>
    <updated>2020-11-06T02:02:20.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/06/travel-by-bus/image.jpeg" class="" title="image.jpeg"><p>&emsp;&emsp;Buses used to be the main means of transportation for the Chinese people. In recent years, with the number of private cars increasing, cities have been facing increasingly severe traffic problems. To encourage more people to travel by bus, many cities have been making efforts to improve bus services. Bus facilities have been continuously renovated, and bus speed has also increased dramatically. However, bus fares are still cheap. Now, in most cities, many local elderly citizens can take a bus for free.</p><p>&emsp;&emsp;公交车曾是中国人出行的主要交通工具。近年来，由于私家车数量不断增多，城市的交通问题越来越严重。许多城市为了鼓励更多人乘坐公交车出行，一直在努力改善公交车的服务质量。车辆的设施不断更新，车速也有了显著提高。然而，公交车的票价却依然相当低廉。现在，在大多数城市，许多当地老年市民都可以免费乘坐公交车。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="traveling" scheme="https://blog.yongkj.cn/tags/traveling/"/>
    
    <category term="bus" scheme="https://blog.yongkj.cn/tags/bus/"/>
    
    <category term="traffic" scheme="https://blog.yongkj.cn/tags/traffic/"/>
    
    <category term="facility" scheme="https://blog.yongkj.cn/tags/facility/"/>
    
  </entry>
  
  <entry>
    <title>The Importance of Writing Ability and How to Develop It</title>
    <link href="https://blog.yongkj.cn/2020/11/06/improve-writing-skills/"/>
    <id>https://blog.yongkj.cn/2020/11/06/improve-writing-skills/</id>
    <published>2020-11-06T01:00:29.000Z</published>
    <updated>2020-11-06T01:42:27.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/06/improve-writing-skills/writing.jpg" class="" title="writing.jpg"><p>&emsp;&emsp;<strong>As the most productive and communicative way to</strong> express ourselves, writing is attached great importance to in all ages. <strong>Whether</strong> we want to improve our writing skills as a creative writer or simply perfect our skills for schoolwork, we can take some steps to learn how to be a better writer.<br>&emsp;&emsp;<strong>Firstly,</strong> in order to make our writing creative and imaginative, brainstorming is one of the key elements to build up a unique topic. Don’t hesitate to take down all the ideas that come into our mind. <strong>Secondly,</strong> a good development of our writing is based on a clear structure or paragraph organization. Even a simple outline will help us see the big picture and save us hours of rewriting. <strong>Finally,</strong> diversity of vocabulary and grammar used in writing is highly recommended for the reason that one of the most common manifestations of bad writing is overuse or reuse of simple language.<br>&emsp;&emsp;<strong>To sum up,</strong> we should take practice and expand our knowledge to become a great writer. With ecough hard work and scientific techniques, we will amaze not only ourselves but also anybody else.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="skill" scheme="https://blog.yongkj.cn/tags/skill/"/>
    
    <category term="writing" scheme="https://blog.yongkj.cn/tags/writing/"/>
    
    <category term="practice" scheme="https://blog.yongkj.cn/tags/practice/"/>
    
    <category term="overuse" scheme="https://blog.yongkj.cn/tags/overuse/"/>
    
  </entry>
  
  <entry>
    <title>Traveling by Plane</title>
    <link href="https://blog.yongkj.cn/2020/11/05/traveling-by-plane/"/>
    <id>https://blog.yongkj.cn/2020/11/05/traveling-by-plane/</id>
    <published>2020-11-05T08:30:04.000Z</published>
    <updated>2020-11-05T08:55:52.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/05/traveling-by-plane/Air-Travel.jpg" class="" title="Air-Travel.jpg"><p>&emsp;&emsp;In the past, traveling by plane was unimaginable for most Chinese people. Today, with development of China’s economy and the improvement of people’s living standards, more and more Chinese people, including many farmers and migrant workers, can travel by air. They can fly to all major cities, and many other cities are also planning to build airports. Air services continue to improve, and there are often cheap flights. In recent years, the number of people choosing to travel by air during holidays has been increasing.</p><p>&emsp;&emsp;过去，乘飞机出行对大多数中国人来说是难以想象的。如今，随着经济的发展和生活水平的提高，越来越多的中国人包括许多农民和外出务工人员都能乘飞机出行。他们可以乘飞机到达所有大城市，还有很多城市也在筹建机场。航空服务不断改进，而且经常会有廉价机票。近年来，节假日期间选择乘飞机外出旅游的人数在不断增加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="improve" scheme="https://blog.yongkj.cn/tags/improve/"/>
    
    <category term="traveling" scheme="https://blog.yongkj.cn/tags/traveling/"/>
    
    <category term="plane" scheme="https://blog.yongkj.cn/tags/plane/"/>
    
    <category term="flight" scheme="https://blog.yongkj.cn/tags/flight/"/>
    
  </entry>
  
  <entry>
    <title>The Importance of Reading Ability and How to Develop It</title>
    <link href="https://blog.yongkj.cn/2020/11/05/improve-reading-skills/"/>
    <id>https://blog.yongkj.cn/2020/11/05/improve-reading-skills/</id>
    <published>2020-11-05T07:51:42.000Z</published>
    <updated>2020-11-05T08:24:24.379Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><img src="/2020/11/05/improve-reading-skills/Reflecting-through-stages-of-Reading-1024x683.jpg" class="" title="Reflecting-through-stages-of-Reading-1024x683.jpg"><p>&emsp;&emsp;<strong>As the most frequently used way to get access to the original material,</strong> reading has always been considered one of the most important parts of language learning. <strong>This explains why reading skills should be highly emphasized.</strong><br>&emsp;&emsp;Then how to improve our reading skills? <strong>First of all,</strong> scan the material before we begin. Whatever the purpose of our reading is, take a few minutes to look the piece over to check and see how the work is structured and presented. <strong>Secondly,</strong> try not to reach for the dictionary when we come to a word we don’t know. Instead, try to guess the meaning of the word based on the context. <strong>Last but not least,</strong> write a few sentences to summarize what we’ve read since it is a way of checking that we understand what we’re reading.<br>&emsp;&emsp;<strong>Above all,</strong> reading has important benefits and can help us learn the language faster and more completely, which encourages each language learner to develop their reading skills as suggested.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="英语学习" scheme="https://blog.yongkj.cn/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="reading" scheme="https://blog.yongkj.cn/tags/reading/"/>
    
    <category term="skill" scheme="https://blog.yongkj.cn/tags/skill/"/>
    
    <category term="improve" scheme="https://blog.yongkj.cn/tags/improve/"/>
    
    <category term="develop" scheme="https://blog.yongkj.cn/tags/develop/"/>
    
  </entry>
  
</feed>
